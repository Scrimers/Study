[
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "리액트란",
        "title" : "리액트란",
        "explain" : "<mark class='gray'>React = React는 페이스북이 만든, MVC 패턴 중 V를 담당하는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리.<br>뷰만 담당하기 때문에 M이나 C는 다른 라이브러리나 패키지로 보완해줘야 한다.<br>react와 바닐라 js로 제작된 웹 사이트의 차이는<br>바닐라 js에서는 element의 변경이 일어나면 전체를 다시 그린다.<br>하지만 react는 변경된 세부 요소만 다시 그리기에 성능적인 면에서 더욱 효율적이다.<br>※리액트는 라이브러리이기는 하지만 Redux나 MobX, react-router와 함께 프레임워크처럼 사용된다.<br>※사용자 인터페이스 = 사용자와 소프트웨어 간의 상호작용을 가능하게 하는 모든 요소를 말한다.<br>예를 들어 버튼, 텍스트 필드, 이미지 등 다양한 UI 요소를 포함한다.<br>※Redux = 상태 관리 라이브러리로, 애플리케이션의 상태를 중앙에서 관리할 수 있도록 도와준다.<br>React와 함께 사용되며, 예측 가능한 상태 관리를 가능하게 한다.<br>※react-router = React 애플리케이션에서 라우팅을 관리하는 라이브러리다.<br>사용자가 URL을 통해 애플리케이션의 다른 부분으로 이동할 수 있도록 도와준다.<br>※프레임워크 = 특정한 구조와 규칙을 제공하여 개발자가 애플리케이션을 구축할 수 있도록 돕는 소프트웨어다.<br>React는 라이브러리로 분류되지만, Redux, react-router와 함께 사용될 때 프레임워크처럼 작동할 수 있다.<br>※바닐라 JS = 기타 js 라이브러리를 사용하지 않은 순수 자바스크립트를 의미한다.<br>즉, 어떠한 프레임워크나 라이브러리를 사용하지 않고, 웹 브라우저에서 기본적으로 제공되는 js를 말한다.<br>바닐라 JS는 대규모 애플리케이션을 관리하거나 복잡한 기능을 구현하는 데는 제한적일 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "사용용도",
        "explain" : "<mark class='gray'>단일 페이지 애플리케이션(SPA)이나 웹 애플리케이션의 일부분을 개발할 때 사용되며,<br>사용자 인터페이스를 구성하는 데 있어서 재사용 가능한 UI 컴포넌트를 만들고 관리하는 데 중점을 둔다.<br>※단일 페이지 애플리케이션(SPA) = 웹 애플리케이션의 한 형태로, 페이지가 새로 고침되지 않고도 사용자와 상호작용할 수 있도록 설계된 애플리케이션이다.<br>React는 SPA를 구축하는 데 매우 적합하다.<br>※웹 애플리케이션 = 웹 브라우저를 통해 접근할 수 있는 소프트웨어 애플리케이션이다.<br>서버와 클라이언트 간의 상호작용을 통해 동적으로 콘텐츠를 제공할 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "특징",
        "explain" : "<mark class='gray'>1. 선언형<br>상호작용이 많은 UI를 만들 때 생기는 어려움을 줄여준다.<br>개발자는 애플리케이션의 각 상태에 대한 간단한 뷰만 설계하면 된다.<br>react는 데이터가 변경됨에 따라 적절한 컴포넌트만 효율적으로 갱신하고 렌더링한다.<br>선언형 뷰는 코드를 예측 가능하고 디버그하기 쉽게 만들어 준다.<br>여기서 말하는 선언이란 어떤 상태를 어떻게 표현해야 할지를 명시적으로 작성하는 것을 의미하며,<br>이로 인해 개발자가 UI의 논리를 더 쉽게 이해하고 관리할 수 있게 해준다.<br>※렌더링 (Rendering) = react의 컴포넌트가 사용자의 화면에 표시될 UI를 생성하고 브라우저에 보여주는 과정을 뜻한다.<br>유저의 이벤트 발생, 서버의 상태 변화 등에 따라 렌더링이 다시 발생한다.<br>이를 리렌더링 (re-rendering) 이라 한다.<br><br>2. 컴포넌트(component) 기반<br>상태를 관리하는 캡슐화된 컴포넌트를 만들 수 있다.<br>그리고 이를 조합해 더욱 더 복잡하고 유기적인 흐름을 가진 컴포넌트 트리를 만들 수 있다.<br>컴포넌트 로직은 템플릿이 아닌 javascript 혹은 typescript로 작성된다.<br>따라서 다양한 형식의 데이터를 앱 안에서 손쉽게 전달할 수 있고, DOM과는 별개로 상태를 관리할 수 있다.<br>DOM과는 별개로 상태를 관리할 수 있다는 의미는 가상 DOM을 사용한다는 것이다.<br>가상 DOM을 사용하기에 업데이트 빈도가 높아도 그렇게 무리가 가지 않는다.<br>DOM 조작이 브라우저에 엄청 무리를 주기 때문에 가상 DOM을 만들어 달라진 부분만 비교해 업데이트한다.<br>※컴포넌트 = 웹 사이트를 조각낸 것이며, 그 조각 하나 하나가 각자 기능하는 완성품이라고 생각하면 된다.<br>※이러한 컴포넌트는 재사용 가능한 UI의 가장 작은 단위이다. 컴포넌트는 javascript, typescript의 함수형 또는 class 형식으로 구현할 수 있다.<br>※결국 컴포넌트는 독립적으로 기능해야하며, 재사용 가능해야 한다.<br>DOM (Document Object Model)<br>※DOM = html은 계층적 구조로 되어 있기에 객체로 표현이 가능하다.<br>이렇게 HTML구조를 객체로서 표현한 것이 DOM이다.<br>웹 페이지에 새로운 요소를 추가하거나 기존 요소를 변경함으로써 웹 페이지를 동적으로 만들 수 있다.<br>※가상 DOM = 실제 DOM에서 처리하는 방식이 아닌 Virtual DOM과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화하는 프로그래밍 개념이다.<br>해당 DOM을 컴포넌트 단위로 쪼개어 HTML 컴포넌트 조립품 처럼 다루는 개념이다.<br>react가 사용하는 구조로, 실제 DOM과 동기화하여 변경된 부분만 업데이트하여 렌더링 성능을 최적화해준다.<br>※typescript = js에 정적 타입을 추가한 슈퍼셋 언어로, 마이크로소프트에서 개발하였다.<br>컴파일 시점에서 타입 오류를 체크하여 개발자의 실수를 방지하고 코드의 가독성을 높여 개발을 도와준다.<br>줄여서 ts라고도 지칭하기도 한다.<br>TypeScript로 작성된 코드는 JavaScript로 컴파일되어 실행된다.<br>※슈퍼셋 언어 = 다른 언어의 기능을 포함하면서 추가적인 기능이나 문법을 제공하는 언어를 의미한다.<br>예를 들어 TypeScript는 JavaScript의 슈퍼셋이다.<br>※정적 타입 = 변수의 데이터 타입이 컴파일 시점에 결정되는 프로그래밍 언어의 특성을 의미한다.<br>즉, 변수를 선언할 때 그 변수의 타입을 명시해야 하며, 이후에는 해당 타입에 맞는 값만 할당할 수 있다.<br>정적 타입 언어의 예로는 Java, C++, TypeScript 등이 있다.<br>정적 타입 언어의 작동 원리는 다음과 같다.<br>정적 타입 언어 = 소스코드 -> 컴파일 시작 -> 컴파일러 작동 -> 컴파일 종료 -> 사용자가 프로그램 실행 -> 런타임 실행<br>※컴파일 = 소스 코드를 기계어 또는 중간 코드로 변환하는 과정이다.<br>이 과정은 일반적으로 컴파일러라는 프로그램에 의해 수행된다.<br>컴파일된 프로그램은 실행 시점에 더 빠르게 실행될 수 있으며, 일반적으로 정적 타입 언어에서 사용된다.<br>컴파일은 프로그램 실행 전에 이루어 진다.<br>※컴파일러 = 소스 코드를 분석하고, 문법 오류를 체크한 후, 최적화된 기계어 코드로 변환하여 실행 가능한 파일을 생성한다.<br>컴파일러는 전체 소스 코드를 한 번에 기계어로 변환한다.<br>※동적 타입 = 변수의 데이터 타입이 런타임 시점에 결정되는 프로그래밍 언어의 특성을 의미한다.<br>즉, 변수를 선언할 때 타입을 명시할 필요가 없으며, 실행 중에 변수에 할당된 값에 따라 타입이 결정된다.<br>동적 타입 언어의 예로는 JavaScript, Python, Ruby 등이 있다.<br>동적 타입 언어의 작동 원리는 다음과 같다.<br>동적 타입 언어 = 소스코드 -> 인터프리터 시작 -> 인터프리트 실행 -> 인터프리터 종료 -> 사용자가 프로그램 실행 -> 런타임 실행<br>※인터프리터 (Interpreter) = 소스 코드를 한 줄씩 읽고 해석하여 실행하는 프로그램 또는 도구를 의미한다.<br>즉, 소스 코드를 기계어로 변환(컴파일)하지 않고, 실행 시점(런타임)에 직접 해석하여 실행한다.<br>※인터프리트 (Interpret) = 소스 코드를 해석하여 실행하는 과정을 설명할 때 사용.<br>※인터프리터는 소스 코드를 한 줄씩 읽고 실행하는 방식으로, 컴파일 과정이 필요하지 않다.<br>이 경우, 런타임에 타입 검사가 이루어지며, 타입 오류는 프로그램 실행 중에 발생할 수 있다.<br>인터프리터는 소스 코드를 인터프리트하여 실행한다 와 같이 말 할 수 있다.<br>※런타임 = 프로그램이 실행되는 시점을 의미한다.<br>즉, 프로그램이 컴파일된 후 실제로 사용자가 프로그램을 실행할 때의 상태를 나타낸다.<br>런타임 동안 프로그램은 메모리에 로드되고, 사용자 입력을 처리하며, 다양한 연산을 수행한다.<br><br>3. 확장성<br>react를 한번 배움으로써 다양한 부분으로 뻗어 나갈 수 있다.<br>react는 Node 서버에서 렌더링을 할 수도 있고, React Native를 이용하면 모바일 앱도 만들 수 있다.<br><br>즉, react는 가상 DOM을 활용하여 성능을 최적화하고,<br>컴포넌트 기반 아키텍처를 채택하여 재사용 가능하고 모듈화된 컴포넌트를 만들 수 있도록 도와주며,<br>선언적 프로그래밍을 통해 UI와 상태를 관리할 수 있도록 지원한다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "리액트 설치 방법",
        "title" : "CDN 사용",
        "explain" : "<mark class='gray'>아래와 같은 코드를 html - head태그 안에 입력해주면 된다.<br><textarea style='width: 97%;'><script crossorigin src='https://unpkg.com/react@18/umd/react.development.js'></script><br><script crossorigin src='https://unpkg.com/react-dom@18/umd/react-dom.development.js'></script></textarea><br><br>※react를 사용해서 웹사이트를 만들 때마다 매번 이러한 환경 설정을 해줘야 한다면 번거롭기에 이 방식은 잘 사용되지 않는다.<br>※CDN (Content Delivery Network) = CDN은 콘텐츠 전송 네트워크의 약자로,<br>전 세계에 분산된 서버를 사용하여 웹 사이트의 콘텐츠를 더 빠르게 제공하는 기술이다.<br>보통 css, js 파일, 이미지, 폰트 등의 정적 콘텐츠를 CDN을 통해 받으면 사용자가 해당 콘텐츠를 빠르게 다운로드할 수 있다.<br>사용법은 단순하게 링크를 html의 코드에 작성하면 된다.<br>이를 통해 라이브러리를 다운로드하고 호스팅하는데 드는 비용과 서버 부하를 줄일 수 있다.<br>react역시 CDN으로 로드하여 프로젝트에서 사용할 수 있지만<br>react 프로젝트를 만들 때에는 기존 html에 작성하지 않고, <br>react 프로젝트를 자동으로 세팅해주는 CRA 기능을 통해 제작한다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "CRA(create-react-app) 사용",
        "explain" : "<mark class='gray'>create-react-app은 react의 보일러 플레이트이다.<br>CDN 사용방식과는 달리 NodeJS와 Webpack 설치를 해줘야 한다.<br>CRA는 Webpack 설치 및 구현을 자동으로 해주는 편리한 기능이다. <br>때문에 CRA로 react project를 작성하는 것이 가장 많이 사용되는 방법이라고 한다.<br><br>※보일러 플레이트 = 특정 개발작업을 하기 위해 미리 준비된 환경 및 도구 세팅.<br>※NodeJs =  브라우저 환경이 아닌 곳에서도 자바스크립트를 실행할 수 있게 해주는 자바스크립트 런타임 언어.<br>※Webpack = 웹 애플리케이션의 소스 코드 및 리소스를 번들링하고 관리하기 위한 모듈 번들러.<br>※번들 = 여러 개의 프로그램, 라이브러리, 또는 모듈을 하나의 패키지로 묶은 것.<br>사용자는 이 번들을 설치함으로써 여러 개의 소프트웨어를 한 번에 설치할 수 있다.<br>예를 들어, 특정 애플리케이션을 실행하기 위해 필요한 모든 라이브러리와 종속성을 포함한 패키지를 제공하는 경우가 이에 해당한다.<br>※번들링 (Bundling) = 여러 개의 파일이나 자원을 하나의 파일로 묶는 과정.<br>여러 JavaScript 파일, CSS 파일, 이미지 등을 하나의 번들로 묶어 네트워크 요청 수를 줄이고 로딩 속도를 개선하는 데 도움을 준다.<br>번들링을 통해 애플리케이션의 성능을 최적화할 수 있습니다.<br>※모듈 (Module) = 특정 기능이나 역할을 수행하는 독립적인 코드 블록.<br>모듈은 재사용 가능하며, 다른 모듈과 결합하여 더 복잡한 애플리케이션을 구성할 수 있다.<br>JavaScript에서는 ES6 모듈 시스템을 통해 모듈을 정의하고 사용할 수 있다.<br>모듈은 코드의 가독성을 높이고 유지보수를 용이하게 합니다.<br>※모듈 번들러 (Module Bundler) = 여러 개의 모듈을 하나의 파일로 묶어주는 도구.<br>모듈 번들러는 개발자가 작성한 모듈을 분석하고, 의존성을 해결하여 최적화된 번들을 생성힌다.<br>대표적인 모듈 번들러로는 Webpack, Rollup, Parcel 등이 있다.<br>이러한 도구는 애플리케이션의 성능을 향상시키고, 배포를 간소화하는 데 도움을 준다.<br>※정리하자면 번들 = 번들링(모듈 번들러(모듈, 모듈...)) 이런 구조라고 볼 수 있다.<br><br>1) Node.js 설치(LTS버전)<br>CRA는 Node.js 환경에서 실행되므로 Node.js를 설치해야 한다.<br>※좀 더 정확히는 리액트를 사용하는 CRA, Webpack, Babel 같은 도구들이 node.js를 기반으로 만들어져 있기 때문에 node.js를 설치해야 한다.<br>Node.js를 설치하기 위해서는 공식 사이트에서 다운로드 받아 설치하면 된다.<br>( https://nodejs.org/en/ )<br>※Node.js 설치시에는 안전성을 위해 LTS버전으로 설치하면 된다.<br>※LTS(Long Term Support) = 장기 지원되는 버전을 의미한다. 일반 버전과 달리 안정성에 중점을 둔 버전으로, 보안과 버그 방면에서 최신 버전보다 안정적인 버전이다.<br><br>2) Node.js를 설치하면 자동으로 npm이 설치된다.<br>※npm(Node Package Manager) = 프로젝트에 필요한 외부 도구들의 설치를 도와준다.<br><br>3) Node.js와 npm이 정상적으로 설치되었는지 확인해본다.<br>명령프롬프트에서 아래와 같이 테스트해보면 된다.<br>npm설치 확인 = npm -v<br>node.js설치 확인 = node -v<br><br>4) 리액트 프로젝트가 위치할 폴더를 만든다.<br><br>5) CRA설치<br>명령프롬프트 또는 VS Code의 터미널을 킨 뒤 해당 폴더로 이동하여 아래의 명령어를 입력한다.<br>npx create-react-app 프로젝트명<br>※프로젝트 이름은 소문자로만 작성되어야한다. my-react-site 처럼 슬래시로 작성하는 케밥 케이스가 관례이다.<br>※위 명령어를 실행하면 react, react-dom, react-scripts, web-vitals 등의 패키지를 자동으로 설치한다.<br>※react-scripts는 내부적으로 Babel, Webpack을 사용한다.<br>※React = 컴포넌트의 생성, 상태 관리, hook 등의 핵심 기능을 제공하는 리액트 라이브러리다.<br>※react-dom = react의 컴포넌트를 실제 브라우저 DOM에 렌더링하고 관리하는 제공하는 라이브러리다.<br>※react-scripts = 리액트 애플리케이션을 빌드하고 실행하는 데 필요한 스크립트와 설정을 포함하는 패키지.<br>※web-vitals = 웹 성능 측정을 위한 라이브러리.<br>※Babel = 자바스크립트 코드를 최신 버전의 ECMAScript 문법으로 작성하고, 이를 구버전의 브라우저에서도 동작하도록 변환해주는 도구이다. 최신 js 문법을 사용하여 개발을 하면, 모든 브라우저가 해당 문법을 지원하지 않을 수 있다. Babel은 이러한 문제를 해결하기 위해 최신 문법을 구버전의 js로 변환하여 호환성을 보장해주는 역할이다.<br><br>※npx create-react-app 와 npm install -g create-react-app 의 차이 및 자세한 설명은 다음과 같다.<br>npx: Node.js의 패키지 실행 도구로, npm에 설치된 패키지를 실행할 수 있게 해준다. npx를 사용하면 패키지를 전역으로 설치하지 않고도 사용할 수 있다.<br>create-react-app: create-react-app 패키지를 사용하여 새로운 리액트 애플리케이션을 생성한다. npx는 최신 버전의 create-react-app을 자동으로 다운로드하고 실행한다.<br>장점: 항상 최신 버전의 create-react-app을 사용할 수 있으며, 전역 설치가 필요 없으므로 시스템을 깔끔하게 유지할 수 있다.<br>단점 : 전역으로 설치된 것이 아니기에 npx create-react-app 프로젝트명 을 한 프로젝트에만 적용이 된다.<br><br>npm install -g: create-react-app 패키지를 전역(global)으로 설치한다. 즉, 시스템의 모든 프로젝트에서 이 패키지를 사용할 수 있게 된다.<br>※리액트 애플리케이션의 버전은 설치받을때 당시의 최신버전이 다운받아진다.<br>create-react-app: 전역으로 설치된 후, create-react-app 명령어를 사용하여 새로운 리액트 애플리케이션을 생성할 수 있다.<br>npm install -g create-react-app 이후 create-react-app 프로젝트명1, create-react-app 프로젝트명2 를 하게되면 프로젝트1, 프로젝트2가 생성되게 되는데 이떄 두 프로젝트의 버전은 동일하다.<br>장점 : 전역으로 설치되었으므로 이후 생성하는 프로젝트는 전부 동일한 버전을 지니게 된다.<br>단점: 설치 시점의 최신버전을 다운받는다는 것은 npx와 같지만, npx는 자동으로 최신버전으로 갱신되는 반면, npm은 시간이 지나 버전이 갱신되게 되었을 때 다운받았을 때의 버전을 계속 유지하게 된다.<br>즉, 전역으로 설치된 패키지가 오래된 버전일 수 있으며, 여러 프로젝트에서 서로 다른 버전의 create-react-app을 사용할 경우 충돌이 발생할 수 있다.<br>만약 최신버전으로 재갱신하고 싶다면 npm install -g create-react-app을 다시 실행하여 최신 버전으로 업데이트해야 한다.<br>※npx create-react-app 프로젝트명 방식을 권장한다!<br><br>리액트 프로젝트 실행 : 명령프롬프트에서 리액트가 설치된 폴더로 이동 후 npm start 를 입력하면 된다.<br><br>번외) react를 ts와 함께 사용하고 싶을떄<br>npx create-react-app {프로젝트 이름} --template typescript</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "리액트 수동 설치",
        "explain" : "<mark class='gray'>CRA와는 달리 전부 수동으로 react 개발 환경을 구축하는 방법이다.<br><br>1) Node.js 설치(LTS버전)<br>CRA는 Node.js 환경에서 실행되므로 Node.js를 설치해야 한다.<br>※좀 더 정확히는 리액트를 사용하는 CRA, Webpack, Babel 같은 도구들이 node.js를 기반으로 만들어져 있기 때문에 node.js를 설치해야 한다.<br>Node.js를 설치하기 위해서는 공식 사이트에서 다운로드 받아 설치하면 된다.<br>( https://nodejs.org/en/ )<br>※Node.js 설치시에는 안전성을 위해 LTS버전으로 설치하면 된다.<br>※LTS(Long Term Support) = 장기 지원되는 버전을 의미한다. 일반 버전과 달리 안정성에 중점을 둔 버전으로, 보안과 버그 방면에서 최신 버전보다 안정적인 버전이다.<br><br>2) Node.js를 설치하면 자동으로 npm이 설치된다.<br>※npm(Node Package Manager) = 프로젝트에 필요한 외부 도구들의 설치를 도와준다.<br><br>3) Node.js와 npm이 정상적으로 설치되었는지 확인해본다.<br>명령프롬프트에서 아래와 같이 테스트해보면 된다.<br>npm설치 확인 = npm -v<br>node.js설치 확인 = node -v<br><br>4) 리액트 프로젝트가 위치할 폴더를 만든다.<br><br>5) 명령프롬프트 또는 VS Code의 터미널을 킨 뒤 4번에서 만든 폴더로 이동하여 아래의 명령어를 입력한다.<br>npm -y init<br>위 명령어를 입력하면 Node.js 프로젝트 메타데이터 파일인 package.json이 생성된다.<br>※package.json에는 프로젝트의 이름, 버전 등이 저장된다.<br>※npm init 을 입력하면 package.json의 초기 값을 사용자가 수동으로 입력할 수 있다.<br><br>6) 파일을 관리할 폴더를 만든다.<br>일반적으로 React 앱의 소스는 크게 정적 소스와 React 소스로 나뉘며, 각각의 디렉토리에 나누어 관리한다.<br>정적 소스를 저장하는 디렉토리의 이름은 public,<br>React 소스를 저장하는 디렉토리의 이름은 src가 일반적이다.<br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력한다.<br>mkdir public<br>mkdir src<br><br>7) 리액트 패키지를 설치한다.<br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력한다.<br>npm install react<br>npm install react-dom<br>※npm install react react-dom 이렇게 써도 된다.<br><br>※react 버전 확인 : npm view react version<br>※react-dom 버전 확인 : npm view react-dom version<br><br>위 명령어를 실행하면 자동으로 node_modules 디렉토리가 생성되고 내부에는 방금 설치한 패키지 및 의존성이 설치된다.<br>앞으로도 새로운 패키지를 설치하면 node_modules 디렉토리에 설치될 것이다.<br>※package-lock.json 파일도 생성되는데 이곳에는 현재 프로젝트에 설치되어 있는 패키지의 메타데이터가 저장된다.<br><br>8) 테스트를 위한 소스를 작성한다.<br>리액트 앱을 빌드하기 위한 소스에는 다음 세 가지 파일이 필수적으로 포함된다.<br>index.html : 웹페이지 요청 시 반환되는 파일<br>App.jsx : 루트 리액트 컴포넌트 파일<br>index.jsx : App.jsx를 index.html에 렌더링하는 파일<br>각각의 상세 내용은 다음과 같다.<br><br>public 디렉토리에 index.html을 작성한다.<br><textarea style='width: 97%;'><html><head><title>My react project</title></head><body><div id='root'></div><script src='main.js'></script></body></html></textarea><br><br><br>src 디렉토리에 App.jsx을 작성한다.<br><textarea style='width: 97%;'>import React from 'react';export default function App(){return (<h1>Welcome to my react project!</h1>);}</textarea><br><br><br>src 디렉토리에 index.jsx를 생성한다.<br><textarea style='width: 97%;'>import React from 'react';import { createRoot } from 'react-dom/client'; // createRoot를 가져온다.import App from './App';const root = createRoot(document.getElementById('root')); // createRoot를 사용하여 루트를 생성한다.root.render(<App />); // App 컴포넌트를 렌더링한다.</textarea><br><br>9) 컴파일을 위해 Babel을 설치한다.<br>웹브라우저는 JSX 파일을 처리할 수 없기에, Babel을 이용하여 JSX 파일을 웹브라우저가 처리할 수 있는 JS파일로 컴파일해야한다.<br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력히여 Babel을 설치한다.<br>npm install @babel/core @babel/cli @babel/preset-react --save-dev<br><br>명령프롬프트에서 4번에서 만든 폴더의 src 디렉토리 내부로 이동 후 아래의 명령어를 입력히여 Babel을 실행하여 JSX -> JS로 컴파일한다.<br>npx babel App.jsx --presets=@babel/preset-react -o App.js<br>npx babel index.jsx --presets=@babel/preset-react -o index.js<br><br>위 명령어를 실행하고 나면 src 디렉토리 내부에 JS 문법으로 컴파일된 App.js, index.js를 확인할 수 있다.<br><br>10) 번들링을 위해 webpack을 설치한다.<br>9번에서 컴파일된 JS파일은 React, ReactDOM 라이브러리에 의존하고 있으므로<br>브라우저가 웹페이지를 생성하려면 두 라이브러리의 소스까지 함께 전송해주어야 한다.<br><br>여러 개의 소스 파일을 전송할 수도 있겠지만 이는 효율적이지 못하므로<br>컴파일한 소스 파일과 라이브러리 소스파일들을 통합하여 하나의 파일로 만들어 전송하기 위해 번들링을 사용한다.<br><br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력히여 webpack을 설치한다.<br>npm install webpack webpack-cli --save-dev<br><br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력히여 webpack을 실행한다.<br>npx webpack<br><br>위 명령어를 실행하게 되면 <br>루드 디렉토리에 dist 디렉토리가 생성되고, 내부에는 webpack이 생성하는 JS파일의 기본 이름인 main.js가 생성되게 된다.<br>※main.js안에는 컴파일한 소스 파일과 라이브러리 소스파일들을 통합되어 있다.<br><br>11) 프로세스 자동화 (확인필요)<br>매번 코드 입력 후 컴파일, 번들링을 하는 것은 비효율적이므로 이를 자동화 시킨다.<br><br>package.json에서 아래의 스크립트를 입력한다.<br>※아래 스크립트의 홀따옴표를 따옴표로 바꿔야 한다.<br>'scripts': {<br>    'build': 'npm run compile && npm run bundling && npm run copy && npm run clean',<br>    'compile': 'npx babel src --out-dir src --presets=@babel/preset-react --extensions \\'.jsx\\'',<br>    'bundling': 'npx webpack',<br>    'copy': 'cp -r public/. dist/',<br>    'clean': 'find src -type f -name *.js -delete'<br>}<br><br>위 스크립트의 의미는 다음과 같다.<br>compile : src 디렉토리의 모든 JSX 파일을 JS 파일로 컴파일<br>bundling : 모든 리액트 소스를 하나의 파일로 번들링<br>copy : 모든 정적 파일을 dist 디렉토리에 복사<br>clean : compile 작업에서 생성된 모든 JS 파일을 삭제<br><br>위 스크립트를 입력 후 명령프름프트에서 npm run build을 실행 후<br>dist 디렉토리에 있는 모든 파일을 웹서버에 복사하면 React 앱을 서비스할 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "CRA와 수동 설치의 차이",
        "explain" : "Create React App (CRA)로 생성한 프로젝트와 수동으로 React를 설치한 프로젝트 간의 차이점은 기본적인 프로젝트 구조와 설정에 있다.<br><br><mark class='gray'>Create React App (CRA):<br>CRA는 기본적으로 설정된 템플릿을 사용하여 프로젝트를 생성한다.<br>이 템플릿은 src 폴더에 App.js 파일을 포함하고 있으며, 이 파일은 기본적으로 React 애플리케이션의 루트 컴포넌트로 사용된다.<br>CRA는 JSX 파일을 .js 확장자로 사용하도록 설정되어 있다. <br>즉, App.js 파일에서 JSX를 사용할 수 있으며, Babel이 이를 처리하여 JavaScript로 변환한다.<br>따라서 CRA 프로젝트에서는 App.jsx 파일이 기본적으로 제공되지 않는다.</mark><br><br><mark class='gray'>수동 설치한 React 프로젝트:<br>수동으로 React를 설치한 경우, 프로젝트 구조와 파일은 사용자가 직접 설정해야 한다. <br>이 경우, App.jsx 파일을 생성하고 JSX를 사용할 수 있다. <br>수동 설치에서는 파일 확장자에 대한 제한이 없으므로, 사용자가 원하는 대로 .jsx 파일을 만들 수 있다.</mark><br><br>결론적으로, CRA는 기본적으로 App.js 파일을 제공하며, JSX를 사용할 수 있도록 설정되어 있다.<br>반면, 수동 설치한 프로젝트에서는 사용자가 직접 파일을 생성하고 설정해야 하므로, App.jsx 파일이 있을 수 있다.<br>Babel은 두 경우 모두에서 JSX를 처리할 수 있지만, CRA는 기본적으로 .js 파일을 사용하도록 설정되어 있다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "리액트 버전 확인 및 버전 설치",
        "explain" : "<mark class='gray'>현재 리액트 버전 확인: 프로젝트가 설치된 디렉토리에서 다음 명령어를 실행한다.<br>npm list react<br><br>원하는 버전으로 변경: 프로젝트가 설치된 디렉토리에서 다음 명령어를 실행한다.<br>※아래의 예시는 리액트 및 리액트 도메인을 16.8.0버전으로 변경하는 것이다.<br>npm install react@16.8.0 react-dom@16.8.0</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "CRA설치 시 중요 폴더 및 파일 설명",
        "explain" : "<mark class='gray'>node-modules 폴더 :<br>node js와 관련된 패키지 및 파일들이 구성되어있는 폴더이다. 개발자들은 이 폴더를 수동으로 작업할 일이 거의 없다.<br><br>public 폴더 :<br>rendering이 진행되는 단 하나의 html 파일과, 이미지 파일이 저장되는 폴더이다.<br><br>src 폴더 :<br>react와 관련된 컴포넌트와 컴포넌트 모여 하나의 트리로 합쳐지는 root file, 추가 라이브러리 기능들이 위치하는 폴더이다. 개발자들은 대부분 이 폴더내에서 작업을 진행한다.<br><br>src/App.jsx :<br>project에서 만들어진 react 컴포넌트들이 총합되어 모이는 root 컴포넌트이다. 이곳에서 각 페이지 경로마다 렌더링될 react router를 지정하기도 한다.<br><br>src/index.jsx :<br>App.jsx에서 합쳐진 컴포넌트들을 ReactDOM을 통해 브라우저에 렌더링하는 역할을 한다.<br><br>package.json :<br>react의 버전, 추가적으로 설치한 기타 라이브러리들의 버전, npm 명령어들을 관리하는 파일이다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "컴포넌트 및 엘리먼트",
        "explain" : "<mark class='gray'>리액트는 컴포넌트로 구성된다.<br>컴포넌트 = 고유한 로직과 모양을 가진 UI.</mark><br>※컴포넌트는 그 용도에 따라 아주 작은 버튼이 될 수도 있고, 전체 페이지만큼 클 수도 있다.<br><br>리액트 컴포넌트는 최종적으로 HTML로 변환되는 JSX를 반환하는 자바스크립트 함수를 뜻한다.<br><mark class='gray'>리액트 컴포넌트 선언 = function 함수명() { return (JSX문법); }<br>리액트 컴포넌트 호출 = <함수명 /><br>※리액트 컴포넌트는 마치 생성자와 같이 대문자로 시작해야 하며, JSX문법에서 쓰이는 html태그는 소문자로 시작해야 한다.<br>※리액트 컴포넌트는 중첩이 가능하다.<br><br><br>엘리먼트 = react의 기본 단위로, 컴포넌트의 가장 작은 부분을 의미한다. JSX 혹은 TSX를 사용하여 정의하며, react 엘리먼트는 가상 DOM을 생성한다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='ByaRQyj' data-pen-title='컴포넌트' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/ByaRQyj'><br>컴포넌트</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "JSX",
        "title" : "JSX란",
        "explain" : "<mark class='gray'>JSX는 JavaScript XML의 약자로, react에서 사용되는 문법 확장이다.<br>js의 확장 문법이기에 js의 기본 기능이 포함되어 있다.<br>JSX는 react 컴포넌트를 만들 때 사용</mark>되며, XML과 비슷한 문법으로 UI 컴포넌트를 정의할 수 있게 해준다.<br>JSX는 보다 가독성이 높고, 코드를 작성하는데 편의성을 제공한다.<br>하지만 <mark class='gray'>브라우저에서는 바로 실행할 수 없으므로 Babel과 같은 도구를 사용하여 일반 자바스크립트로 변환되어야 한다.</mark><br>※jsx는 웹 공격을 안전하게 막아준다. 모든 항목은 렌더링 되기 전에 문자열로 변환되기특성으로 인해 웹 공격으로 부터 안전하게 막아준다.<br><br><mark class='gray'>JSX는 HTML과 유사하지만, 실제로는 React.createElement 함수로 변환되어 Virtual DOM element를 생성한다.<br>이후 이것은 react의 비교 알고리즘에 의해 실제 DOM 업데이트에 활용된다.</mark><br>※컴포넌트를 만들 때, 굳이 jsx형태로 리엑트를 하지 않아도 된다.<br>React.createElement(태그, 속성, 값) 으로 작성할 수 있다.<br>하지만 일반적으로 jsx문법으로 작성하며, jsx 작성법이 더 간결하고 가독성이 뛰어나다.<br>※typeScript에서는 tsx를 사용한다.<br>※tsx : typeScript를 사용하여 작성된 react 컴포넌트의 확장자를 나타내는 것으로, js 코드에 타입 정보를 포함할 수 있는 기능을 제공한다. typeScript 전용의 jsx라고 볼 수 있다.<br>※tsx 파일 역시 Babel과 같은 도구를 사용하여 일반 js로 변환되며, ts 전용 컴파일러를 통해 타입 검사 및 변환 작업이 추가적으로 수행된다.<br><br><mark class='gray'>버튼의 렌더링 로직과 버튼의 마크업이 함께 있으면, 매번 변화가 생길 때마다 서로 동기화 상태를 유지할 수 있다.</mark> <br>반대로 버튼의 마크업과 사이드바의 마크업처럼 서로 관련이 없는 항목들은 서로 분리되어 있으므로,각각 개별적으로 변경하는 것이 더 안전하다.<br><mark class='gray'>※렌더링 로직 =  컴포넌트가 어떻게 화면에 나타날지를 결정하는 코드를 뜻한다.<br>※예를 들어, 버튼이 클릭되었을 때 어떤 상태가 변화하고, 그에 따라 버튼의 스타일이나 텍스트가 어떻게 변하는지를 설정하는 부분이다.<br>※동기화 상태 = 상태 변화(예: 버튼 클릭)에 따라 마크업이 즉시 업데이트됨으로써 버튼의 상태와 시각적 표현이 항상 일치하게 유지된다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "JSX 사용법",
        "explain" : "<mark class='gray'>1. 하나의 루트 엘리먼트로 반환하기 <br>하나의 컴포넌트에서 하나의 엘리먼트를 반환하려면 그냥 반환하면 되지만<br>하나의 컴포넌트에서 여러 엘리먼트를 반환하려면, 하나의 부모 태그로 감싸야 한다.<br>예를 들어 &lt;div&gt;...&lt;/div&gt; 또는 빈 &lt;&gt;...&lt;/&gt; 래퍼와 같이 전체 JSX가 공유하는 부모로 감싸야 한다.<br>※이러한 것을 루트 엘리먼트로 감싼다고 하다.<br>※빈 &lt;&gt;...&lt;/&gt; 을 Fragment라고 한다.<br>※Fragment는 브라우저상의 HTML 트리 구조에서 흔적을 남기지 않고 그룹화해준다.<br><br>2. 모든 태그는 반드시 닫아야 한다.<br>JSX에서는 &lt;br /&gt;같이 태그를 반드시 닫아야한다.<br><br>3. 캐멀 케이스로 작성한다.<br>stroke-width 대신 strokeWidth로 사용한다.<br>또한 class는 예약어이기 때문에, className으로 사용한다.<br>※aria-*와 data-*의 어트리뷰트는 HTML에서와 동일하게 대시를 사용하여 작성한다.<br><br>※아래의 예시에는 return( JSX문법 ) 이런식으로 사용했지만, JSX문법을 return문 안에서만 쓸 수 있는건 아니다.<br>※return() 은 순수 javascript에서도 쓸 수 있다. 주로 가독성을 위해 여러 줄의 값을 반환할 때 사용된다.※JSX 내에서 JavaScript 표현식(예를 들어 map)을 사용할 때는 항상 중괄호 {}로 감싸야 한다.<br>JSX 문법 내에서는 for문 사용이 불가능하다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='mydmOpV' data-pen-title='JSX' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/mydmOpV'><br>JSX</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "export",
        "explain" : "export default = JavaScript 모듈 시스템에서 사용되는 구문.<br><mark class='gray'>특정 모듈에서 기본적으로 내보내고자 하는 값을 지정하는 데 사용된다.<br>이 구문을 사용하면 해당 모듈을 가져오는 다른 파일에서 이 값을 쉽게 가져올 수 있다.<br><br>※export default 는 하나의 파일에서 한번만 선언을 할 수 있다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='wBvdoZr' data-pen-title='export default' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br>  <span>See the Pen <a href='https://codepen.io/scrimer/pen/wBvdoZr'><br>  export default</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>  on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "class 속성",
        "explain" : "<mark class='gray'>리액트에서는 태그의 클래스 속성을 명시할 때 class로 쓰지 않고, className으로 쓴다.<br>※만약 class로 쓰게되면 에러가 발생하게 된다.<br>※className으로 코드를 작성 후 결과를 개발자도구로 보게되면 class로 변환되어 있는 걸 확인할 수 있다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='YPzVOdR' data-pen-title='class 속성' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/YPzVOdR'><br>class 속성</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "JSX문법 내 변수 값 노출 및 객체 정의",
        "explain" : "<mark class='gray'>JSX를 사용하면 JavaScript 파일에 HTML과 비슷한 마크업을 작성할 수 있어 렌더링 로직과 콘텐츠를 같은 곳에 둘 수 있다.<br>또한 마크업 내부에 JavaScript 로직을 추가하거나 동적인 프로퍼티를 참조할 수 있다.<br>이를 위해 JSX에서 중괄호를 사용하여 사용할 수 있다.<br><br>아래는 JSX안에서 JavaScript를 사용하는 방법에 대한 간략한 설명이다.<br><br>1. 따옴표로 문자열 전달 = &lt;img className='문자열'/&gt;<br>※문자열을 작은따옴표나 큰따옴표로 감싸주면 된다.<br><br>2. 속성 값을 동적으로 지정<br>conat asd = '문자열';<br>&lt;img className= {asd}/&gt;<br>※{asd}는 변수 그 자체를 전달하지만 '{asd}'는 '{asd}'이라는 문자열을 전달하는 거다.<br>마치 1번처럼 말이다.<br><br>3. 값을 동적으로 지정<br>conat asd = '문자열';<br>&lt;h1&gt;{asd}입니다.&lt;/h1&gt;<br><br>4. 함수 그 자체를 동적으로 지정<br>const today = new Date();<br><br>function formatDate(date) {<br>  return new Intl.DateTimeFormat(<br>    'en-US',<br>    { weekday: 'long' }<br>  ).format(date);<br>}<br><br>export default function TodoList() {<br>  return (<br>    &lt;h1&gt;To Do List for {formatDate(today)}&lt;/h1&gt;<br>  );<br>}<br><br>5. 객체의 속성을 동적으로 지정<br>const asd = {<br>  a: 'aaaa',<br>  b: {<br>    b1: 'black',<br>    b2: 'pink'<br>  }<br>};<br><br>export default function TodoList() {<br>  return (<br>    &lt;div style={asd.b}&gt;<br>      &lt;h1&gt;{asd.a}'s Todos&lt;/h1&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>6. style 속성을 동적으로 지정<br>※style 속성과 같이 여러개의 속성 값이 정의 될 수 있는 경우 중괄호를 두 번 써야한다.<br><br>JSX문법 내 style 속성 값으로 변수 사용법 : {{속성키 : 속성값, 속성키 : 속성값}}<br>※위 예시를 상세히 파악하자면 다음과 같다.<br>※첫 번째 중괄호 {}: JSX에서 JavaScript 표현식을 사용하기 위해 필요하다. 이 중괄호는 JSX가 JavaScript 코드를 인식하도록 한다.<br>※두 번째 중괄호 {}: 이 부분은 실제 JavaScript 객체를 나타낸다. 객체는 {}로 감싸진 속성과 값을 키:값 으로 정의한 것이다.</mark><br>※속성키의 경우 카멜케이스로 적어야 한다. 예를 들어 기존 html에서 &lt;ul style='background-color: black'&gt;이라고 썼다면<br>&nbsp;리액트에서는 &lt;ul style={{ backgroundColor: 'black' }}&gt; 로 써야한다.<br><br>결론적으로 단순히 변수 값을 노출할 때는 중괄호를 한 쌍만 쓰면 되지만,<br>객체를 선언해야 할 때는 중괄호를 두 쌍을 써야 한다.<br>※오해하면 안되는게 JSX문법 내에서만 {객체변수명.속성키}를 쓰는 거지, JSX문법이 없는 곳에서는 javascript와 같이 객체변수명.속성키를 쓰면 된다." ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='qEBmJpv' data-pen-title='Untitled' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/qEBmJpv'><br>Untitled</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "속성(props)",
        "explain" : "<mark class='gray'>props(=properties)는 JSX 태그에 전달하는 데이터이자, 컴포넌트 간에 데이터를 전달하기 위해 props 를 사용한다.<br>모든 부모 컴포넌트는 자식 컴포넌트에 props를 제공하여 정보를 전달할 수 있다.<br>Props는 객체, 배열, 함수를 포함한 모든 JavaScript 값이 전달될 수 있으며, JSX도 가능하다.<br>props는 컴포넌트에 대한 유일한 인자이다!<br>또한 props의 값이 지정되지 않았을 때 기본값을 지정해주는 것도 가능하다.<br><br><br>1. 내부에서 porps사용법<br>※이는 'JSX문법 내 변수 값 노출 및 객체 정의'에서 다뤘던 내용이기도 하다.<br>function Asd() {<br>    const 변수1 = 값;<br>    const 변수2 = 값;<br>    return(<br>        &lt;div&gt;<br>        {변수1}<br>        {변수2}<br>        {변수1 + 변수2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>2. 부모 컴포넌트로부터 props로 전달받기 (구조 분해 할당 방식)<br>※아래의 예시에서 눈여겨 봐야 할 부분은 Child( {전달할props명1, 전달할props명2} ) 와 같이 파라미터부분에 중괄호로 props를 보낸다는 부분이다.<br>※{전달할props명1, 전달할props명2} 이렇게 props를 세분화해서 보내는 방식을 구조 분해 할당 방식이라고 한다.<br><br>function Parent() {<br>    const 변수1 = 값;<br>    const 변수2 = 값;<br>    return(<br>        &lt;Child 전달할props명1={변수1} 전달할props명2={변수2} /&gt;<br>    );<br>}<br><br>function Child( {전달할props명1, 전달할props명2} ) {<br>    return(<br>        &lt;div&gt;<br>        {전달할props명1}<br>        {전달할props명2}<br>        {전달할props명1 + 전달할props명2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>3. 부모 컴포넌트로부터 props로 전달받기 (객체로 보내기)<br>function Parent() {<br>    const 변수 = {<br>        변수1 : 값,<br>        변수2 : 값<br>    };<br>    return(<br>        &lt;Child 전달할props명={변수} /&gt;<br>    );<br>}<br><br>function Child( {전달할props명} ) {<br>    return(<br>        &lt;div&gt;<br>        {전달할props명.변수1}<br>        {전달할props명.변수2}<br>        {전달할props명.변수1 + 전달할props명.변수2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>4. spread 문법으로 props 전달하기<br>※아래의 예시에서 눈 여겨 볼 부분은 {...전달할props명} 이다.<br>※위와 같은 것을 spread 문법이라 하기도 하고 전개 연산자라고 하기도 한다.<br>※spread 문법을 사용하면 GrandParent컴포넌트로부터 props를 전달받은 Parent컴포넌트가 <br>Child 컴포넌트에게 props를 전달할 떄 구조 분해 할당 방식으로 보내게 되어 function Child( {변수1, 변수2} ) 과 같이 사용할 수 있게 해준다.<br>※객체로 props를 그룹화 하여 전달하는 방식과 spread 문법으로 props를 전달하는 방식의 가장 큰 차이점은 다음과 같다.<br>객체로 props를 그룹화 하여 전달하는 방식 = 변수명.객체 로 접근해야 한다.<br>spread 문법으로 props를 전달하는 방식 = 객체 로 접근해야 한다.<br><br>function GrandParent() {<br>    const 변수 = {<br>        변수1 : 값;<br>        변수2 : 값;<br>    };<br>    return(<br>        &lt;Parent 전달할props명={변수} /&gt;<br>    );<br>}<br><br>function Parent( {전달할props명} ) {<br>    return(<br>        &lt;Child {...전달할props명} /&gt;<br>    );<br>}<br><br>function Child( {변수1, 변수2} ) {<br>    return(<br>        &lt;div&gt;<br>        {변수1}<br>        {변수2}<br>        {변수1 + 변수2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>5. 자식을 JSX로 전달하기<br>부모 컴포넌트 안에 자식 컴포넌트가 중첩되어 있는 경우 부모 컴포넌트는 자식 컴포넌트에 대한 정보를 children 이라는 props로 받을 수 있다.<br>※children은 className과 같이 예약어이다. 반드시 children을 써야 한다.<br><br>function Comp({test, children }) {<br>  return (<br>    &lt;&gt;<br>    &lt;div className='card'&gt;<br>      {children}    //ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ<br>    &lt;/div&gt;<br>    &lt;span&gt;{test}&lt;/span&gt; //777<br>    &lt;/&gt;<br>  );<br>}<br><br>export default function Main() {<br>  return (<br>    &lt;Comp test={'777'}&gt;<br>      ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ<br>    &lt;/Comp&gt;<br>  );<br>}<br><br><br>6. props 기본값 지정하기<br>※전달할props명2 = 100 부분이 기본값을 지정한 부분이다.<br>※기본값은 전달할props명2 이 없거나 전달할props명2={undefined}로 전달될 때 사용된다.<br>※그러나 전달할props명2={null} 또는 전달할props명2={0}으로 전달된다면, 기본값은 사용되지 않는다.<br>※즉, 초기화가 되지 않은 값인 경우에는 기본값이 적용될 수 있으나 모종의 이유로 값 자체가 null이나 0이 들어온 경우엔 기본값이 세팅되지 않는다는 것이다.<br><br>function Asd( {전달할props명1, 전달할props명2 = 100} ) {  <br>}<br></mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='pvoLOee' data-pen-title='props' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/pvoLOee'><br>props</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "조건부 렌더링",
        "explain" : "<mark class='gray'>if 또는 삼항연산자 등을 통하여 조건에 따라 렌더링이 가능하게 할 수 있다.<br>※JSX문법 밖에서는 if, &&, 삼항연산자 전부 쓸 수 있지만 JSX문법 내에서는 if는 쓸 수 없다.<br>※각각의 컴포넌트는 반드시 무언가를 반환해야 하는데 조건에 따라 아무런 JSX도 반환하지 않아야 한다면 return null을 사용할 수 있다.<br><br>조금 헷갈리는 내용이 있어서 적는다.<br>function Asd() {<br>    const branch = true;<br>    const name = '777';<br>    return(<br>        &lt;div&gt;<br>        예시 1<br>        {branch ? name + '9' : name}<br><br>        예시 2<br>        {branch ? &lt;s&gt;{name + '9'}&lt;/s&gt; : name}<br><br>        예시 3<br>        {branch ? &lt;s&gt;{name + '9'}&lt;b&gt;{name + '7'}&lt;/b&gt;&lt;/s&gt; : name}<br><br>        예시 4<br>        {name}<br><br>        예시 5<br>        {branch ? &lt;s&gt;{name + '9'}{branch ? &lt;i&gt;{name}&lt;/i&gt; : name}&lt;/s&gt; : name}<br><br>        예시 6<br>        {name} {branch && '9'}<br>        &lt;/div&gt;<br>    );<br>}<br>위 코드에서 공통적으로 쓰인 {branch ? ...} 부분은 조건부 렌더링(javascript 문법)을 쓰기 위해 중괄호가 감싸진다.<br>여기서 예시 1의 경우 이미 조건부 렌더링을 통해 중괄호로 쌓여있으니 변수를 노출할때 name + '9' 와 같이 바로 변수명을 노출해주면 된다.<br>반면 예시 2의 경우 &lt;s&gt; 태그라는 JSX문법이 또 쓰이게 되므로 그 안에서 변수를 쓰기위해선 {name + '9'} 이렇게 중괄호로 감싸져야 한다.<br>또 다른 특이한 케이스로 예시 6의 경우 branch && '9'에서 branch가 true면 '9'라는 값을 반환한다.<br>만약 branch가 false라면 아무런 값도 반환하지 않게 된다.<br>※&&의 왼쪽에 숫자를 두면 안된다.JavaScript는 자동으로 왼쪽을 부울로 변환하기 떄문에 왼쪽이 0이면 리액트는 0을 렌더링하게 된다.<br>※즉, messageCount && &lt;p&gt;New messages&lt;/p&gt; 가 아닌 messageCount &gt; 0 && &lt;p&gt;New messages&lt;/p&gt; 처럼 써야 한다는 것이다.<br><br>이를 글로써 정리해보자면 아래와 같다.<br>1. JSX문법 내에서 변수를 사용하기 위해선 {변수} 로 사용한다.<br>2. JSX문법 내에서 조건부 렌더링을 사용하기 위해선 {조건부 렌더링} 으로 사용한다.<br>3. 조건부 렌더링 내에서 변수를 사용할 때는 이미 중괄호로 감싸진 상태이므로 중괄호 없이 변수명을 쓰면 된다.<br>4. 조건부 렌더링 내에서 JSX문법이 들어가게되고 그 안에 변수가 사용될 때는 {변수} 로 사용한다.<br>5. JSX문법의 태그(예를 들어 b태그나 i태그)등이 중첩되어 있더라도 같은 JSX문법 내이므로 {{변수}} 가 아닌 {변수}로 쓰인다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='emYWoWz' data-pen-title='조건부 렌더링' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/emYWoWz'><br>조건부 렌더링</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "리스트 렌더링",
        "explain" : "<mark class='gray'>컴포넌트 리스트를 렌더링하기 위해서는 for 문 및 map() 함수와 같은 자바스크립트 기능을 사용해야 한다.<br>여기서 주의할 점은 map()은 JSX 문법내에서 사용이 가능하지만 for문은 JSX문법 내에서는 사용이 불가능하다는 것이다.<br><br>JSX 내에서 map() 사용 : {변수.map((item, index) =&gt; (로직))}<br>※(item, index) 라고 적힌 부분은 그 명칭을 달리 할 수 있다.<br>※만약 item만 쓰고 싶은 경우에는 {변수.map(item =&gt; (로직))} 으로 사용할 수 있다.<br>※반드시 JSX 내에서 map() 사용에 적은 것처럼 중괄호가 있어야 한다.<br>※그 이유는 JSX 내에서 JavaScript 표현식(예를 들어 map)을 사용할 때는 항상 중괄호 {}로 감싸야 하기 떄문이다.<br><br>JSX 내에서 filter() 사용 : 새로운 변수 = {필터링 할 변수.filter(item =&gt; (item == '값'))}<br>※다른 기능도 마찬가지지만 filter와 map을 붙여서 사용할 수 있다.<br>※새로운 변수 = 기존 변수.filter(data =&gt; data.값 == 값).map((item, index) =&gt; 로직)<br><br>※화살표 함수는 암시적으로 =&gt; 바로 뒤에 식을 반환하기 때문에 return 문이 필요하지 않다.<br>※예시 : const listItems = chemists.map(person =&gt; &lt;li&gt;...&lt;/li&gt; // 암시적 반환! );<br>※하지만 =&gt; 뒤에 중괄호가 오는 경우 return을 명시적으로 작성해야 한다.<br>※예시 : const listItems = chemists.map(person =&gt; { // 중괄호 return &lt;li&gt;...&lt;/li&gt;; });<br>※중괄호를 표현하는 화살표 함수를 “block body”를 가지고 있다고 말한다.<br>※이 함수를 사용하면 한 줄 이상의 코드를 작성할 수 있지만 return 문을 반드시 작성해야 한다. <br>※그렇지 않으면 아무것도 반환되지 않는다.<br><br>리액트에서는 key속성이 있다.<br>key속성은 리스트를 렌더링할 때 각 요소를 고유하게 식별하기 위해 사용된다.<br>※key속성은 임의의 명칭이 아닌 고정된 명칭이다.<br>Key를 사용하면 리스트가 변경되더라도 React가 각 항목의 위치를 추적할 수 있다.<br>key속성은 리액트 내부 알고리즘에서 사용되며, 실제 DOM요소에는 나타나지 않는다.<br>따라서 key속성을 입력했으나 개발자 도구에서 해당 태그에 key 속성이 보이지 않는 것은 정상적인 동작이다.<br>※map() 호출 내부의 JSX 엘리먼트에는 항상 key가 필요하다.<br>※일반적으로 데이터베이스에서 가져온 ID를 key로 사용하게 될 것이다.<br><br>※key는 변경되어서는 안 되므로 렌더링 중에는 key를 생성하지 않아야 한다.<br>※잘못된 예시1 : <br>{items.map((item, index) =&gt; (<br>    // 잘못된 예: 인덱스를 key로 사용 (변경될 수 있음)<br>    &lt;li key={index}&gt;{item}&lt;/li&gt;<br>))}<br>※위의 예시에서 index를 key로 사용하면, 리스트의 순서가 변경될 때마다 key가 변경될 수 있다. 이는 React가 요소를 올바르게 인식하지 못하게 만들 수 있다.<br><br>※잘못된 예시2 : <br>{items.map((item) =&gt; (<br>    &lt;li key={Math.random()}&gt;{item.name}&lt;/li&gt;<br>))}<br>※key={Math.random()}처럼 즉석에서 key를 생성하면 안된다.<br>※위와 같이 하면 렌더링 간에 key가 일치하지 않아 모든 컴포넌트와 DOM이 매번 다시 생성될 수 있다.<br>※이는 속도가 느려질 뿐만 아니라 리스트 항목 내부의 모든 사용자의 입력도 손실된다.<br><br>※올바른 예시 : <br>{items.map((item) =&gt; (<br>    // 올바른 예: 고유한 id를 key로 사용<br>    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;<br>))}<br><br>※key를 작성 시 짧은 &lt;&gt; &lt;/&gt; fragment 구문으로는 key를 전달할 수 없으므로 key를 단일 &lt;div&gt;로 그룹화하거나 약간 더 길고 명시적인 &lt;Fragment&gt; 문법을 사용해야 한다.<br>※예시 : <br>const listItems = people.map(person =&gt;<br>  &lt;Fragment key={person.id}&gt;<br>    &lt;h1&gt;{person.name}&lt;/h1&gt;<br>    &lt;p&gt;{person.bio}&lt;/p&gt;<br>  &lt;/Fragment&gt;<br>);<br>※Fragment는 DOM에서 사라지므로 위 예시 대로라면 &lt;h1&gt;, &lt;p&gt;, &lt;h1&gt;, &lt;p&gt; 등의 평평한 리스트가 생성된다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='zxYwQOp' data-pen-title='리스트 렌더링' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/zxYwQOp'><br>리스트 렌더링</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "컴포넌트 순수하게 유지",
        "explain" : "컴포넌트를 순수하게 유지한다는 것은 <mark class='gray'>함수형 프로그래밍을 지향</mark>한다는 의미이다.<br><mark class='gray'>함수형 프로그래밍을 지향하는 이유는 코드가 길어져도 예상밖의 동작 및 버그를 피할 수 있기 떄문이다.</mark><br><br><mark class='gray'><br>함수형 프로그래밍을 하기 위해서는 다음과 같은 규칙을 지켜야 한다.<br>1. 함수가 같은 파라미터를 받았을 때, 같은 return 값이 나와야 한다.<br>2. 함수가 호출되기 전 존재했던 변수의 데이터는 절대 훼손되서는 안된다.<br>-> 즉, 외부에 선언된 변수의 데이터는 절대 변경되면 안된다는 것이며, 반대로 함수 내부에 선언된 변수의 데이터의 경우 같은 렌더링 동안 생성된 것이기 때문에 변경되어도 괜찮다.<br>-> 이렇게 내부에서 생성되고, 변경되는 것을 지역 변경이라고 한다.<br></mark><br><br>또한 이벤트 핸들러가 컴포넌트 내부에 정의되었다 하더라도 렌더링 중에는 실행되지 않으므로 이벤트 핸들러는 순수할 필요가 없다." ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='NPWELXY' data-pen-title='컴포넌트 순수하게 유지' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/NPWELXY'><br>컴포넌트 순수하게 유지</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "이벤트 핸들러",
        "title" : "이벤트 핸들러 추가",
        "explain" : "<mark class='gray'>이벤트 핸들러 함수는 다음과 같은 특징을 가지고 있다.<br>1. 주로 컴포넌트 내부에서 정의된다.<br>2. handle로 시작하고 그 뒤에 이벤트명을 붙인 함수명을 가진다.<br>(ex : onClick={handleClick}, onMouseEnter={handleMouseEnter})<br>※이벤트명을 붙인 함수는 코드상의 이슈때문이 아닌 편의성을 위함이다.<br><br><br>이벤트 핸들러를 추가하기 위한 방법은 크게 4가지가 있다.<br>1. 인라인 스타일로 정의하기 - 함수 표현식<br>&lt;button onClick={function handleClick() {<br>  alert('You clicked me!');<br>}}&gt;<br><br>2. 인라인 스타일로 정의하기 - 화살표 함수<br>&lt;button onClick={() =&gt; {<br>  alert('You clicked me!');<br>}}&gt;<br><br>3. 이벤트 핸들러 내에서 Prop 읽기 <br>function BtnComp({msg, children}) {<br>  return(<br>    &lt;button onClick={() =&gt; alert(msg)} &gt;<br>    {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>function Asd() {<br>  return(<br>    &lt;BtnComp msg='!!!'&gt;<br>    버튼을 클릭하세요.<br>    &lt;/BtnComp&gt;<br>  );<br>}<br><br>4. 이벤트 핸들러를 Prop으로 전달하기<br>// 1) 컴포넌트 생성<br>function Asd() {<br>    // 2) 이벤트 함수 선언 및 내부 로직 작성 <br>    function handleClick() {<br>        alert('You clicked me!');<br>    }<br>    return(<br>        // 3) 이벤트 핸들러를 추가 및 2)에서 선언한 이벤트 함수 props로 전달받기<br>        &lt;button onClick={handleClick}&gt;AAA&lt;/button&gt;<br>    );<br>}<br><br>5. 이벤트 핸들러 Prop 명명하기 <br>&lt;button&gt;과 &lt;div&gt; 같은 빌트인 컴포넌트는 onClick과 같은 브라우저 이벤트 이름 만을 지원한다.<br>그러나 사용자 정의 컴포넌트에서는 이벤트 핸들러 prop의 이름을 원하는 대로 명명할 수 있다.<br>※관습적으로 이벤트 핸들러 prop의 이름은 on으로 시작하여 대문자 영문으로 이어진다.<br>※아래의 예시에서 이벤트 핸들러 Prop 명명한 부분은 사용자 정의 컴포넌트인 Button에서 쓰인 onMsg이다.<br>function Button({onMsg, children}) {<br>  return(<br>    &lt;button onClick={onMsg}&gt;<br>    {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>function Asd() {<br>  return(<br>    &lt;Button onMsg={() =&gt; alert('!!!!!!!!')}<br>    btn 1<br>    &lt;/Button&gt;<br><br>    &lt;Button onMsg={() =&gt; alert('@@@@@@@@@')}<br>    btn 2<br>    &lt;/Button&gt;<br>  );<br>}</mark><br><br>※굳이 사용할려면 리액트 프로젝트에서도 addEventListener를 쓸 수 있지만, 리액트가 내부적으로 addEventListener를 사용하여 이벤트를 처리하므로 굳이 쓸 필요는 없다.<br><br><br>여기서 한가지 주의할 점은 html의 경우 &lt;button onClick=이벤트 함수명()&gt; 으로 사용하지만<br>리액트에서는 () 없이 &lt;button onClick={이벤트 함수명}&gt; 으로 사용한다는 것이다.<br><br>이에 대해 보다 자세히 설명하자면 아래와 같다.<br>&lt;button onClick=함수명()&gt; 또는 &lt;button onClick={alert('!!!')}&gt;<br>의 경우 버튼이 렌더링 될 때, 함수명()을 통해 함수를 호출했으니 결과는 발생한 상태이지만,<br>브라우저의 이벤트루프로 인해 그 결과가 사용자에게 노출되지 않은 상태이며, <br>사용자가 해당 이벤트를 실행하면 그때 그 결과를 노출해 준다.<br><br>&lt;button onClick={함수명}&gt; 또는 &lt;button onClick={() =&gt; alert('!!!')}&gt;<br>의 경우 리액트에서 자동으로 이벤트리스너를 등록한다.<br>이는 AddEventListener('click', 함수명) 과 동일하다.<br>함수명()이 아닌 함수명 이기 때문에 함수를 호출한 것이 아닌, <br>함수를 참조하고 있는 것이며 이는 콜백이기 때문에 결과는 발생하지 않은 상태이다.<br>이후 사용자가 이벤트를 실행하면 그때 콜백을 통해 해당 함수가 실행되고,<br>사용자에게 그 결과가 노출된다.<br><br>결국 위의 <br><br>이하는 좀 TMI이지만 궁금증 해소를 위해 적는다.<br>성능적인 측면에서 위의 두 방식은 각각의 장단점을 갖는다. 이를 간단히 적자면 다음과 같다.<br>&lt;button onClick=함수명()&gt;<br>장점 : 최초 렌더링 시 결과를 지니고, 사용자가 이벤트를 실행할 때마다 저장된 결과를 노출하기만 하면 되므로 이벤트가 자주 발생해도 부담이 덜하다.<br>단점 : 렌더링이 자주 일어나게 되면, 불필요한 연산이 일어나게 된다.<br><br>&lt;button onClick={함수명}&gt;<br>장점 : 사용자가 이벤트를 실행할 때만 결과가 노출되므로 렌더링이 자주 일어나도 문제가 없다.<br>단점 : 사용자가 이벤트를 자주 실행하게 되면, 이벤트 실행 시마다 결과를 연산하고, 노출해야 하므로 성능 저하가 생길 수 있다." ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='gbORgGR' data-pen-title='이벤트에 응답' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/gbORgGR'><br>이벤트에 응답</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "이벤트 전파",
        "explain" : "<mark class='gray'>부모 컴포넌트가 자식 컴포넌트의 이벤트를 전파받는걸 뜻한다.<br><br>1. 이벤트 전파<br>function Toolbar() {<br>  return (<br>    &lt;div onClick={() =&gt; {<br>      alert('You clicked!');<br>    }}&gt;<br>      &lt;button onClick={() =&gt; alert('Playing!')}&gt;<br>        Play Movie<br>      &lt;/button&gt;<br>      &lt;button onClick={() =&gt; alert('Uploading!')}&gt;<br>        Upload Image<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>위 컴포넌트에서 Play Movie버튼을 클릭하게 되면 Playing! 다음에 You clicked! 가 노출된다.<br>만약 Upload Image버튼을 클릭하게 되면 Uploading! 다음에 You clicked! 가 노출된다.<br>※onScroll을 제외한 React 내의 모든 이벤트는 전파된다.<br>위의 예시에서 중요한 점은 onClick={() =&gt; { alert('You clicked!'); }} 이다.<br>만약 onClick={alert('You clicked!')} 을 하면 영역 또는 버튼을 클릭하기 전에 렌더링이 완료되자마자 alert이 뜨게 된다.<br>이는 즉시호출때문에 그런것이다.<br>그래서 영역 또는 버튼을 클릭했을때만 alert이 뜨게 하려면 onClick={() =&gt; { alert('You clicked!'); }} 을 써야 한다.<br><br><br>2. 이벤트 전파 멈추기<br>이벤트 핸들러는 이벤트 오브젝트를 유일한 매개변수로 받는다.<br>※관습적으로 이벤트 오브젝트는 e라는 명칭을 쓴다.<br>이 매개변수를 통해 이벤트 정보를 읽을 수 있으며, 이를 이용해 전파를 멈출 수 있게 할 수 있다.<br>e.stopPropagation()를 쓰면 된다.<br><br>function Button({ onClick, children }) {<br>  return (<br>    &lt;button onClick={e =&gt; {<br>      e.stopPropagation();<br>      onClick();<br>    }}&gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>3. Capture<br>전파가 중단되었다 해도 자식 컴포넌트의 모든 이벤트를 캡처해 확인해야 할 경우에 쓰인다.<br>이벤트명 마지막에 Capture를 추가하면 된다고는 하는데,<br>어지간해서는 이걸 쓸 일은 없을 거라 생각된다.<br>해당 내용은 필요 시 찾아보도록 하자.<br><br>4. 이벤트 핸들러 전달 시 전파 멈추기<br>부모 영역인 div를 클릭했을 때의 이벤트는 방지하고 자식에게 전달되는 alert만 이벤트가 발생한다.<br>export default function MainComp() {<br>  const parentAlert = () =&gt; alert('부모 alert');<br>  return (<br>    &lt;div onClick={parentAlert}&gt;<br>      &lt;Button onClick={() =&gt; alert('전달한 alert')}&gt;<br>        버튼임<br>      &lt;/Button&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>function Button({onClick, children}) {<br>  return (<br>      &lt;button onClick={e =&gt; {<br>        e.stopPropagation();<br>        onClick();<br>      }}&gt;<br>      {children} <br>      &lt;/button&gt;<br>  );<br>}<br><br>5. 기본 동작 방지하기<br>일부 브라우저 이벤트는 그와 관련된 기본 브라우저 동작을 가진다.<br>예로 &lt;form&gt;의 이벤트는 그 내부의 버튼을 클릭 시 페이지 전체를 리로드하는 것이 기본 동작이다.<br>이를 방지하기 위해 아래와 같이 하면 된다.<br><br>export default function Signup() {<br>  return (<br>    &lt;form onSubmit={e =&gt; {<br>      e.preventDefault();<br>      alert('Submitting!');<br>    }}&gt;<br>      &lt;input /&gt;<br>      &lt;button&gt;Send&lt;/button&gt;<br>    &lt;/form&gt;<br>  );<br>}<br><br>※e.stopPropagation()와 e.preventDefault()는 서로 다른 기능이다 상세 기능은 아래와 같다.<br>e.stopPropagation()은 이벤트 핸들러가 상위 태그에서 실행되지 않도록 멈춘다.<br>e.preventDefault() 는 기본 브라우저 동작을 가진 일부 이벤트가 해당 기본 동작을 실행하지 않도록 방지한다.<br></mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "상태(state)",
        "explain" : "컴포넌트는 상호 작용의 결과로 화면의 내용을 변경해야 하는 경우가 많다. <br>컴포넌트는 현재 입력값, 현재 이미지, 장바구니에 담긴 상품 등을 기억해야 한다.<br>React에서는 이러한 컴포넌트별 메모리를 state라고 부른다.<br><br>useState Hook을 사용하면 컴포넌트에 state를 추가할 수 있다.<br>Hooks는 컴포넌트가 React의 주요 기능(state는 그중 하나임.)을 사용할 수 있도록 해주는 특별한 함수다.<br><mark class='gray'>useState Hook을 사용하면 state 변수를 선언할 수 있다.</mark><br>useState는 초기 state를 인자로 받으며, 현재 상태와 상태를 업데이트할 수 있는 상태 설정 함수를 배열에 담아 반환한다.<br><br><mark class='gray'>const [index, setIndex] = useState(0);<br>위의 예시를 보자면 index는 state 변수이며, setIndex는 state 변수의 상태를 업데이트 할 수 있는 상태 설정 함수인 것이다.</mark><br><br><mark class='gray'>state를 활용 시 주의해야 할 점이 있는데<br>지역 변수의 값이 변경되어도 React는 렌더링을 트리거하지 않으며,<br>컴포넌트가 다시 렌더링될 때마다 지역 변수는 초기화되지만 <br>State 변수는 렌더링 간에 값을 유지하며, 변경 시 렌더링을 트리거한다는 것이다.<br>죽, React는 단순히 지역 변수 값이 바뀐다고 해서 새로운 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못한다.<br>따라서 컴포넌트의 상태를 관리하고 화면에 반영하려면 useState를 사용해야 한다.</mark><br><br><mark class='gray'>state를 사용하기 위해선 다음과 같이 하면 된다.<br>import { useState } from 'react';<br>const [명칭, set명칭] = useState(초기값);<br><br>const [명칭, set명칭]에서 첫번째 명칭 = 상태값(처음에는 초기값)이 세팅되는 변수. 이후 set명칭을 통해 업데이트 된 값이 들어가게 된다.<br>const [명칭, set명칭]에서 두번째 set명칭 = 상태를 업데이트 하는 함수. 안의 로직에 의해 변경된 값에 따라 상태를 변경하고 컴포넌트를 다시 렌더링하여 UI를 업데이트한다.</mark><br><br>※명칭은 반드시 [명칭, set명칭]으로 할 필요는 없다. 예를 들어 [a, b] 이런식으로 해도 상관없다.<br>※하지만 일반적으로 [명칭, set명칭]으로 작성한다.<br>※useState의 초기값은 반드시 Number일 필요는 없다.<br><mark class='gray'>※초기값으로 문자열, 객체, 배열 등 어떤 데이터 타입도 사용할 수 있다.</mark><br>※[와 ] 문법을 배열 구조 분해라고 하며, 배열로부터 값을 읽을 수 있게 해준다. useState가 반환하는 배열에는 항상 두 개의 항목이 있다.<br><br><mark class='gray'>※set명칭(3)과 명칭 = 3 의 차이<br>※set명칭(3)는 React의 상태 업데이트 함수로, 상태를 변경하고 컴포넌트를 다시 렌더링한다. 즉, 명칭의 값을 3으로 설정하고, 그에 따라 렌더링을 통해 UI가 업데이트된다.<br>※반면에 명칭 = 3은 단순히 변수 명칭의 값을 변경하는 것이며, React의 상태 관리 시스템과는 관계가 없다. 즉 명칭=3은 React가 상태 변경을 인식하지 못하므로 UI가 업데이트되지 않는다. 따라서 setCount를 사용해야 한다.</mark><br><br><br>const [index, setIndex] = useState(0);<br>위와 같은 코드가 실행되게 된다면 다음과 같은 순서로 진행되게 된다.<br>1. 컴포넌트가 처음 렌더링 된다. index의 초깃값으로 useState를 사용해 0을 전달했으므로 [0, setIndex]를 반환한다. React는 0을 최신 state 값으로 기억한다.<br>2. state를 업데이트한다. 사용자가 버튼을 클릭하면 setIndex(index + 1)를 호출한다. index는 0이므로 setIndex(1)이다. 이는 React에 index는 1임을 기억하게 하고 또 다른 렌더링을 유발한다.<br>3. 컴포넌트가 두 번째로 렌더링 돤다. React는 여전히 useState(0)를 보지만, index를 1로 설정한 것을 기억하고 있기 때문에, 이번에는 [1, setIndex]를 반환한다.<br><br><br><mark class='gray'>state의 또 다른 특징으로서 동일한 컴포넌트를 두 번 렌더링한다면 각 복사본은 완전히 격리된 state를 가지게 된다.<br>즉, 둘 중 하나를 변경해도 다른 하나에는 영향을 미치지 않게 된다는 것이다.<br>아래의 예시와 같다.<br>export default function Page() {<br>  return (<br>    &lt;div className='Page'&gt;<br>      &lt;Gallery /&gt;<br>      &lt;Gallery /&gt;<br>    &lt;/div&gt;<br>  );<br>}<br>※Gallery 컴포넌트 안에 useState가 있음<br>위와 같은 코드에서 첫번째 Gallery을 상호작용해도 두번째 Gallery에는 아무런 영향을 미치지 않는다.<br>쉽게 말해 자식 컴포넌트 각각에 state가 있으므로 서로 독립적으로 작동할 수 있게 되는 것이다.<br><br>만약 Gallery컴포넌트가 서로의 상태를 동기화한 상태로 작동하게 하려면<br>Gallery 컴포넌트 안의 useState를 제거하고 Page(부모)컴포넌트에 해당 useState를 추가하면 상태를 공유하게 만들 수 있다.<br></mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='xbxrmdg' data-pen-title='상태(state)' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/xbxrmdg'><br>상태(state)</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "Hook",
        "explain" : "<mark class='gray'>use로 시작하는 함수를 Hook이라고 한다.</mark><br>예시에서 사용된 는 React에서 제공하는 내장 Hook이다.<br>Hook 종류는 여러가지가 있다.<br><br><mark class='gray'>Hook은 컴포넌트의 최상위 레벨에서만 호출해야 한다.</mark><br>이는 React의 상태 관리와 렌더링 최적화를 위해 필요한 규칙이다.<br><br>또한 <mark class='gray'>조건문이나 반복문 안에서 Hook을 호출하면 안된다.<br>React가 상태를 추적하는 데 어려움을 겪게 되어 예기치 않은 동작이 발생할 수 있기 떄문이다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='JojJxmw' data-pen-title='Hook' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/JojJxmw'><br>Hook</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "상품 테이블 실습",
        "explain" : "" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='dPyVyaY' data-pen-title='상품 테이블 실습' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/dPyVyaY'><br>상품 테이블 실습</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "렌더링에 대하여",
        "explain" : "<mark class='gray'>렌더링이 일어나는 과정은 3가지 단계로 이뤄진다.<br><br>1단계 : 렌더링 트리거<br>컴포넌트 렌더링이 되기 위해 렌더링 트리거를 발생시키는 경우는 두 가지이다.<br><br>1. 컴포넌트의 초기 렌더링인 경우<br>앱을 시작할 때 초기 렌더링을 트리거해야 한다.<br>아래와 같은 방법을 쓰면 된다.<br>const root = createRoot(document.getElementById('root'))<br>root.render(렌더링할 컴포넌트);<br><br>2. 컴포넌트의 state가 업데이트된 경우<br>set 함수를 통해 상태를 업데이트하여 추가적인 렌더링을 트리거한다.<br>컴포넌트의 상태를 업데이트하면 자동으로 렌더링 대기열에 추가된다.<br><br><br>2단계 : React 컴포넌트 렌더링<br>렌더링을 트리거한 후 React는 컴포넌트를 호출하여 화면에 표시할 내용을 파악한다.<br>즉, 렌더링은 React에서 컴포넌트를 호출하는 것이다.<br><br>최초의 렌더링은 루트 컴포넌트를 호출하는 것이다.<br>그 이후의 렌더링은 state 업데이트가 일어나 렌더링을 트리거한 컴포넌트를 호출하는 것이다.<br><br><br>3단계 : React가 DOM에 변경사항을 적용<br>최초의 렌더링의 경우 appendChild() 를 사용하여 생성한 모든 DOM 노드를 화면에 표시한다.<br>그 이후의 렌더링(리렌더링)의 경우 DOM이 최신 렌더링 출력과 일치하도록 한다.<br>이때 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경한다.<br>즉, 아무런 변경사항이 없다면 DOM 노드를 변경하지 않는다는 것이다.<br></mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "snapshot으로서의 state",
        "explain" : "<mark class='gray'>state 변수를 설정하여도 이미 가지고 있는 state 변수는 변경되지 않고, 대신 리렌더링이 발동된다.</mark><br>console.log(count);  // 0<br>setCount(count + 1); // 1<br>console.log(count);  // 0<br><br><br><mark class='gray'>클릭과 같은 사용자 이벤트에 반응하여 사용자 인터페이스가 직접 변경된다고 생각할 수 있지만<br>인터페이스가 이벤트에 반응하려면 state를 업데이트해야 한다.</mark><br><br>export default function Form() {<br>  const [isSent, setIsSent] = useState(false);<br>  const [message, setMessage] = useState('Hi!');<br>  if (isSent) {<br>    return &lt;h1&gt;Your message is on its way!&lt;/h1&gt;<br>  }<br>  return (<br>    &lt;form onSubmit={(e) =&gt; {<br>      e.preventDefault();<br>      setIsSent(true);<br>      sendMessage(message);<br>    }}&gt;<br>      &lt;textarea<br>        placeholder='Message'<br>        value={message}<br>        onChange={e =&gt; setMessage(e.target.value)}<br>      /&gt;<br>      &lt;button type='submit'&gt;Send&lt;/button&gt;<br>    &lt;/form&gt;<br>  );<br>}<br><br>function sendMessage(message) {<br>  // ...<br>}<br><br>위 코드는 아래와 같이 동작한다.<br>1. 버튼 클릭 시 onSubmit 이벤트 핸들러가 실행됩니다.<br>2. setIsSent(true)가 isSent를 true로 설정하고 새로운 렌더링을 큐에 넣습니다.<br>3. React는 새로운 isSent값에 따라 컴포넌트를 다시 렌더링합니다.<br><br><br><mark class='gray'>렌더링이란 컴포넌트를 호출한다는 뜻이다.<br>이때 렌더링 당시의 state를 사용해 계산된다.<br>즉, 다음과 같은 순서로 진행된다.<br>1. React가 함수를 다시 호출한다.<br>2. 함수가 새로운 JSX 스냅샷을 반환한다.<br>3. React가 함수가 반환한 스냅샷과 일치하도록 현재 state값을 사용해 화면을 업데이트한다.</mark><br><br>export default function Counter() {<br>  const [number, setNumber] = useState(0);<br><br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;{number}&lt;/h1&gt;<br>      &lt;button onClick={() =&gt; {<br>        setNumber(number + 1);<br>        setNumber(number + 1);<br>        setNumber(number + 1);<br>      }}&gt;+3&lt;/button&gt;<br>    &lt;/&gt;<br>  )<br>}<br><br>위와 같은 코드가 있을 때 컴포넌트안에 setNumber는 3개지만<br>버튼을 누를때 당시의 number는 0이므로 결과값은 1이 되게 된다.<br>다음으로 버튼을 누르면 number는 1이므로 결과값은 2가 되게 된다.<br><br>또 다른 예시로 아래와 같은 코드가 있다.<br>export default function Counter() {<br>  const [number, setNumber] = useState(0);<br><br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;{number}&lt;/h1&gt;<br>      &lt;button onClick={() =&gt; {<br>        setNumber(number + 5);<br>        setTimeout(() =&gt; {<br>          alert(number);<br>        }, 3000);<br>      }}&gt;+5&lt;/button&gt;<br>    &lt;/&gt;<br>  )<br>}<br><br>버튼을 누를 당시의 number는 0이므로, setNumber의 결과값은 5다.<br>마찬가지로 alert도 당시의 number는 0이므로, 결과값은 0이다.<br>비록 setTimeout이 있지만 <br><mark class='gray'>state 변수의 값은 이벤트 핸들러의 코드가 비동기적이더라도 렌더링 내에서 절대 변경되지 않는다.<br>state 변수 값은 컴포넌트를 호출해 React가 UI의 스냅샷을 찍을 때 고정된 값이다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupStart",
        "reStudy" : "y",
        "mainTitle" : "state 업데이트를 연속으로 대기열에 추가하기",
        "title" : "state batch",
        "explain" : "<mark class='gray'>React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린다.<br>이러한 동작을 batching 이라고 하며 이 동작은 React 앱을 훨씬 빠르게 실행할 수 있게 해준다.<br>React는 클릭과 같은 여러 이벤트에 대해 batch를 수행하지 않으며, 각 클릭은 개별적으로 처리된다.<br>React는 안전한 경우에만 batch를 수행한다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트",
        "explain" : "<mark class='gray'>setNumber(number + 1)와 setNumber(n =&gt; n + 1)은 동작방식이 다음과 같다.<br>setNumber(number + 1) = 다음 state 값을 전달<br>setNumber(n =&gt; n + 1) = 이전 큐의 state를 기반으로 다음 state를 계산하는 함수를 전달</mark><br>※setNumber(n =&gt; n + 1)는 단순히 state 값을 대체하는 것이 아니라 React에 state 값으로 무언가를 하라고 지시하는 방법이다.</mark><br><br>export default function Counter() {<br>  const [number, setNumber] = useState(0);<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;{number}&lt;/h1&gt;<br>      &lt;button onClick={() =&gt; {<br>        setNumber(n =&gt; n + 1);<br>        setNumber(n =&gt; n + 1);<br>        setNumber(n =&gt; n + 1);<br>      }}&gt;+3&lt;/button&gt;<br>    &lt;/&gt;<br>  )<br>}<br><br>여기서 <mark class='gray'>n =&gt; n + 1 은 업데이터 함수(updater function)라고 부른다.<br>최초 number state는 0이었으므로 React는 이를 첫 번째 업데이터 함수에 n 인수로 전달한다. <br>그 후 이전 업데이터 함수의 반환 값을 가져와서 다음 업데이터 함수에 n으로 전달하는 식으로 반복한다.</mark><br>결과적으로 버튼을 클릭하면 3이라는 값이 나오게 된다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "state를 교체한 후 업데이트",
        "explain" : "<mark class='gray'>&lt;button onClick={() =&gt; {<br>  setNumber(number + 5);<br>  setNumber(n =&gt; n + 1);<br>}}&gt;<br>위 코드는 아래와 같이 작동한다.<br>1. setNumber(number + 5) : number는 0이므로 setNumber(0 + 5)이다.<br>React는 큐에 5로 바꾸기 를 추가한다.<br>2. setNumber(n =&gt; n + 1) : n =&gt; n + 1는 업데이터 함수다.<br>React는 해당 함수를 큐에 추가한다.<br>3. React는 6을 최종 결과로 저장하고 useState에서 반환한다.<br></mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "업데이트 후 state 변경",
        "explain" : "&lt;button onClick={() =&gt; {<br>  setNumber(number + 5);<br>  setNumber(n =&gt; n + 1);<br>  setNumber(42);<br>}}&gt;<br><br>위 코드는 아래와 같이 동작한다.<br><mark class='gray'>1. setNumber(number + 5): number 는 0 이므로 setNumber(0 + 5) 이다.<br>React는 5로 바꾸기를 큐에 추가한다.<br>2. setNumber(n =&gt; n + 1): n =&gt; n + 1 는 업데이터 함수이다.<br>React는 이 함수를 큐에 추가한다.<br>3. setNumber(42): React는 42로 바꾸기를 큐에 추가한다.<br>4. React는 42를 최종 결과로 저장하고 useState에서 반환한다.<br><br>이벤트 핸들러가 완료되면 React는 리렌더링을 실행한다. <br>리렌더링하는 동안 React는 큐를 처리한다. <br>업데이터 함수는 렌더링 중에 실행되므로, 업데이터 함수는 순수해야 하며 결과만 반환 해야한다.<br>※업데이터 함수 내부에서 state를 변경하거나 다른 사이드 이팩트를 실행하려고 하면 안된다.</mark><br>※Strict 모드에서 React는 각 업데이터 함수를 두 번 실행(두 번째 결과는 버림)하여 실수를 찾을 수 있도록 도와준다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "명명 규칙",
        "explain" : "업데이터 함수 인수의 이름은 해당 state 변수의 첫 글자로 지정하는 것이 일반적이다.<br><br>setEnabled(e => !e)<br>setLastName(ln => ln.reverse())<br>setFriendCount(fc => fc * 2)" ,
        "howUse" : ""       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "객체 State 업데이트하기",
        "title" : "객체 State 사용법",
        "explain" : "<mark class='gray'>State는 객체를 포함한 모든 종류의 자바스크립트 값을 가질 수 있다.<br>그러나 React state에 있는 객체와 배열을 직접 변경해서는 안 된다.<br>객체의 값을 변경하고 싶을 때는 새로운 객체를 생성하여 (또는 기존 객체의 복사본을 만들어), state가 복사본을 사용하도록 해야 한다.<br>일반적으로 변경하려는 객체나 배열을 복사하기 위해 ... 전개 구문을 사용한다. <br></mark><br>export default function MovingDot() {<br>  const [position, setPosition] = useState({<br>    x: 0,<br>    y: 0<br>  });<br>  return (<br>    &lt;div<br>      onPointerMove={e =&gt; {<br>        position.x = e.clientX;<br>        position.y = e.clientY;<br>      }}<br>    &gt;      <br>    &lt;/div&gt;<br>  )<br>}<br>    <br>위 코드에서 position.x = e.clientX 는 작동하지 않는다.<br>이유는 state 설정 함수를 사용해서 상태가 변경된 것이 아니기 때문에 리액트는 값이 변경되었는질 몰라 리렌더링을 하지 않기 때문이다.<br>이런 경우에  <mark class='gray'>리렌더링을 발생시키려면, 새 객체를 생성하여 state 설정 함수로 전달하면 된다.</mark><br>아래와 같이 바꾸면 된다.<br><br>onPointerMove={e =&gt; {<br>  setPosition({<br>    x: e.clientX,<br>    y: e.clientY<br>  });<br>}}<br><br>또 다른 예시로 아래와 같이 쓸 수도 있다.<br>아래 코드의 경우도 위 코드와 마찬가지로 state 변수의 값을 직접적으로 변경한 것이 아니며,<br>state에 영향이 가지 않는 새로운 객체에 값을 부여하여 그 값을 기존의 state 설정 함수에 전달한 것이다.<br><br>const nextPosition = {};<br>nextPosition.x = e.clientX;<br>nextPosition.y = e.clientY;<br>setPosition(nextPosition);<br><br>위와 같은 방식을 지역 변경(local mutation) 이라고 한다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "전개 문법으로 객체 복사하기 ",
        "explain" : "폼에서 단 한 개의 필드만 수정하고, 나머지 모든 필드는 이전 값을 유지하고 싶을 수 있다.<br><br>예를 들어 아래와 같은 코드가 있을 때<br>const [person, setPerson] = useState({<br>    firstName: 'Barbara',<br>    lastName: 'Hepworth',<br>    email: 'bhepworth@sculpture.com'<br>});<br><br>function handleFirstNameChange(e) {<br>    person.firstName = e.target.value;<br>}<br><br>function handleLastNameChange(e) {<br>    person.lastName = e.target.value;<br>}<br><br>function handleEmailChange(e) {<br>    person.email = e.target.value;<br>}<br>위 코드는 state 상태를 변경하는 것이 아닌 state 변수 값을 직접적으로 변경하고 있다.<br>당연히 리렌더링 트리거는 작동하지 않을 것이므로 정상적으로 작동하지 않는 코드이다.<br><br><br>위 코드를 정상적으로 변경하기 위해선 아래와 같이 바꿔야 할 것이다.<br>function handleFirstNameChange(e) {<br>    setPerson({<br>        firstName: e.target.value,<br>        lastName: person.lastName,<br>        email: person.email<br>    });<br>}<br>하지만 위 코드의 단점은 각각의 함수에 setPerson을 설정할때마다<br>값이 변경될 프로퍼티 + 기존의 값을 유지하기 위한 프로퍼티의 값을 세팅 해줘야 한다는 것이다. <br><br><br>이를 보다 간편하게 만들기 위해 아래와 같이 할 수 있다.<br>function handleFirstNameChange(e) {<br>    setPerson({<br>        ...person,<br>        firstName: e.target.value<br>    });<br>}<br>위와 같은 방식을 객체 전개 구문이라고 하며<br><mark class='gray'>객체 전개 구문을 사용하면 모든 프로퍼티를 전부 복사한다.<br>※만약 프로퍼티가 중첩되어 있는 상태라면 객체 전개 구문을 중첩사용해야 할 수도 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "여러 필드에 단일 이벤트 핸들러 사용하기",
        "explain" : "<mark class='gray'>[ 와 ] 괄호를 객체 정의 안에 사용하여 동적 이름을 가진 프로퍼티를 명시할 수 있다.</mark><br>const [person, setPerson] = useState({<br>    firstName: 'Barbara',<br>    lastName: 'Hepworth',<br>    email: 'bhepworth@sculpture.com'<br>});<br><br>function handleChange(e) {<br>    setPerson({<br>        ...person,<br>        [e.target.name]: e.target.value<br>    });<br>}<br><br>...<br><br>return (<br>    &lt;input<br>        name='firstName'<br>        value={person.firstName}<br>        onChange={handleChange}<br>    /&gt;<br>)<br><mark class='gray'>※e.target.name은 &lt;input&gt;의 name 프로퍼티를 나타낸다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "중첩된 객체 갱신하기",
        "explain" : "const [person, setPerson] = useState({<br>    name: 'Niki de Saint Phalle',<br>    artwork: {<br>        title: 'Blue Nana',<br>        city: 'Hamburg',<br>        image: 'https://i.imgur.com/Sd1AgUOm.jpg',<br>    }<br>});<br>위와 같이 <mark class='gray'>중첩된 객체가 있을때 state의 상태를 업데이트하기 위한 방법은 2가지가 있다.</mark><br><br>1. <br>const nextArtwork = { ...person.artwork, city: 'New Delhi' };<br>const nextPerson = { ...person, artwork: nextArtwork };<br>setPerson(nextPerson);<br>위 코드의 작동방식을 순서대로 보자면 아래와 같다.<br>1) ...person.artwork를 통해 artwork의 모드 속성을 복사할 것이라 명시한다.<br>2) city: 'New Delhi'를 통해 city의 값을 변경할 것이라 명시한다.<br>3) 1), 2) 내용을 변수 nextArtworkㅇ에 담는다.<br>4) ...person을 통해 person state 변수 내의 모든 속성을 복사할 것이라 명시한다.<br>5) artwork: nextArtwork를 통해 3)에서 명시한 내용들을 통해 값을 변경할 것이라 명시한다.<br>6) setPerson(nextPerson); 를 통해 결론적으로 person.artwork.city의 state 변수 값을 변경한다.<br><br>2.<br>setPerson({<br>    ...person, // 다른 필드 복사<br>    artwork: { // artwork 교체<br>      ...person.artwork, // 동일한 값 사용<br>      city: 'New Delhi' // 하지만 New Delhi!<br>    }<br>  });<br>1번과 같은 작동방식이다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "Immer",
        "explain" : "Immer를 사용하면 중첩된 객체를 평탄화시킬 수 있다.<br>Immer는 변경 구문을 사용할 수 있게 해주며 복사본 생성을 도와주는 라이브러리이다.<br>Immer는 업데이트 핸들러를 간결하게 관리할 수 있는 좋은 방법이며<br>특히 state가 중첩되어 있고 객체를 복사하는 것이 중복되는 코드를 만들 때 유용하다.<br><br>Immer는 대략적으로 아래와 같이 사용한다.<br>updatePerson(draft => {<br>    draft.artwork.city = 'Lagos';<br>});<br>Immer는 내부적으로 draft의 어느 부분이 변경되었는지 알아내어, 변경사항을 포함한 완전히 새로운 객체를 생성한다.<br><br><br>Immer를 사용하기 위해서는 아래와 같이 하면 된다.<br>1. package.json에 dependencies로 use-immer를 추가한다.<br>2. npm install을 실행한다.<br>3. import { useState } from 'react'를 import { useImmer } from 'use-immer'로 교체한다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "배열 State 업데이트하기",
        "title" : "개요",
        "explain" : "객체와 마찬가지로 state에 저장된 배열을 업데이트하고 싶을 떈<br>새 배열을 생성(혹은 기존 배열의 복사본을 생성)한 뒤, 새 배열을 state로 두어 업데이트해야한다.<br>즉, 배열의 값을 직접적으로 변경하는 push()나 pop()같은 함수를 쓰면 안된다.<br><br>아래는 리액트에서 쓰이지 않아야 할 배열함수와 쓰여야 할 배열함수이다.<br><br>추가 함수<br>사용X : push, unshift<br>사용O : concat, [...arr] 전개 연산자<br><br>사용X : pop, shift, splice<br>사용O : filter, slice<br><br>사용X : splice, arr[i] = ... 할당<br>사용O : map<br><br>사용X : reverse, sort<br>사용O : 배열을 복사한 이후 처리" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "배열에 항목 추가하기 ",
        "explain" : "push()의 기능은 다음과 같이 쓸 수 있다.<br>setArtists(<br>  [<br>    ...artists, // 기존 배열의 모든 항목에<br>    { id: nextId++, name: name } // 마지막에 새 항목을 추가.<br>  ]<br>);<br><br><br>unshift()의 기능은 다음과 같이 쓸 수 있다.<br>setArtists([<br>  { id: nextId++, name: name }, // 추가할 항목을 앞에 배치하고<br>  ...artists // 기존 배열의 항목들을 뒤에 배치.<br>]);" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "배열에서 항목 제거하기",
        "explain" : "<mark class='gray'>배열에서 항목을 제거하는 가장 쉬운 방법은 필터링하는 것이다.<br>필터링을 하게되면 설정한 항목을 포함하지 않은 새 배열을 제공한다.</mark><br><br>let initialArtists = [<br>  { id: 0, name: 'Marta Colvin Andrade' },<br>  { id: 1, name: 'Lamidi Olonade Fakeye'},<br>  { id: 2, name: 'Louise Nevelson'},<br>];<br><br>...<br><br>const [artists, setArtists] = useState(<br>    initialArtists<br>);<br><br>...<br><br>&lt;ul&gt;<br>    {artists.map(artist =&gt; (<br>      &lt;li key={artist.id}&gt;<br>        {artist.name}{' '}<br>        &lt;button onClick={() =&gt; {<br>          setArtists(<br>            artists.filter(a =&gt;<br>              a.id !== artist.id<br>            )<br>          );<br>        }}&gt;<br>          Delete<br>        &lt;/button&gt;<br>      &lt;/li&gt;<br>    ))}<br>&lt;/ul&gt;<br><br>위 코드 중 artists.filter(a =&gt; a.id !== artist.id) 는<br>artist.id와 ID가 다른 artists로 구성된 배열을 생성한다 라는 의미이다.<br>즉, 각 Delete 버튼은 해당 artist를 배열에서 필터링한 다음, 반환된 배열로 리렌더링을 요청한다.<br>filter가 원본 배열을 수정하지 않는다는 점에 주의해야한다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "배열 변환 및 항목 교체하기",
        "explain" : "<mark class='gray'>배열의 일부 또는 전체 항목을 변경하고자 한다면, map()을 사용해 새로운 배열을 만들 수 있다.</mark><br><br>let initialShapes = [<br>  { id: 0, type: 'circle', x: 50, y: 100 },<br>  { id: 1, type: 'square', x: 150, y: 100 },<br>  { id: 2, type: 'circle', x: 250, y: 100 },<br>];<br><br>...<br><br>const [shapes, setShapes] = useState(<br>  initialShapes<br>);<br><br>...<br><br>function handleClick() {<br>  const nextShapes = shapes.map(shape => {<br>    if (shape.type === 'square') {<br>      // 변경시키지 않고 반환<br>      return shape;<br>    } else {<br>      // 50px 아래로 이동한 새로운 원을 반환<br>      return {<br>        ...shape,<br>        y: shape.y + 50,<br>      };<br>    }<br>  });<br>  <br>  setShapes(nextShapes);  // 새로운 배열로 리렌더링<br>}<br><br><br>인덱스를 활용하는 방법은 다음과 같다.<br>let initialCounters = [<br>  0, 0, 0<br>];<br><br>...<br><br>const [counters, setCounters] = useState(<br>    initialCounters<br>);<br><br>...<br><br>function handleIncrementClick(index) {<br>  const nextCounters = counters.map((c, i) => {<br>    if (i === index) {<br>      // 클릭된 counter를 증가<br>      return c + 1;<br>    } else {<br>      // 변경되지 않은 나머지를 반환<br>      return c;<br>    }<br>  });<br>  setCounters(nextCounters);<br>}" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "배열에 항목 삽입하기",
        "explain" : "<mark class='gray'>시작, 끝이 아닌 중간에 항목을 삽입하기 위해선 slice() 함수를 사용할 수 있다.</mark><br>let nextId = 3;<br>const initialArtists = [<br>  { id: 0, name: 'Marta Colvin Andrade' },<br>  { id: 1, name: 'Lamidi Olonade Fakeye'},<br>  { id: 2, name: 'Louise Nevelson'},<br>];<br><br>...<br><br>const [artists, setArtists] = useState(<br>  initialArtists<br>);<br><br>...<br><br>function handleClick() {<br>  const insertAt = 1;<br>  const nextArtists = [<br>    // 삽입 지점 이전 항목<br>    ...artists.slice(0, insertAt),<br>    // 새 항목<br>    { id: nextId++, name: name },<br>    // 삽입 지점 이후 항목<br>    ...artists.slice(insertAt)<br>  ];<br>  setArtists(nextArtists);<br>}" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "배열에 기타 변경 적용하기(중요)",
        "explain" : "<mark class='gray'>reverse() 및 sort() 함수등은 원본 배열을 변경시키므로 직접 사용할 수 없다.<br>대신, 먼저 배열을 복사한 뒤 변경할 수 있다.</mark><br><br>const initialList = [<br>  { id: 0, title: 'Big Bellies' },<br>  { id: 1, title: 'Lunar Landscape' },<br>  { id: 2, title: 'Terracotta Army' },<br>];<br><br>...<br><br>const [list, setList] = useState(initialList);<br><br>function handleClick() {<br>  const nextList = [...list]; //기존의 list변수에 담긴 배열을 전부 얕은 복사를 한다.<br>  nextList.reverse();         //배열을 뒤집는다.<br>  setList(nextList);<br>}<br><br>위 코드에서 주의할 점은 <br><mark class='gray'>배열을 복사하더라도 배열 내부의 기존 항목을 직접 변경해서는 안된다는 것이다.<br>얕은 복사를 한 것이기 때문에 state변수인 list변수의 값을 참조하고 있다.<br>따라서 복사된 배열 내부의 객체를 수정하면 기존 state 변수인 list의 값이 변경되게 된다.<br>※변수 initialList의 값은 변경되지 않는다.<br>※state 변수인 list 변수는 initialList의 값을 참조하고 있는 것이 아닌 복사가 된 독립된 개체이기 떄문이다.<br><br>아래와 같은 코드를 주의하라는 것이다.<br>const nextList = [...list];<br>nextList[0].seen = true; // list[0]을 변경시킨다.<br>setList(nextList);<br><br>이해를 위해 좀 더 상세히 설명하자면<br>nextList와 list는 서로 다른 배열이지만, nextList[0]과 list[0]은 동일한 객체를 가리킨다.<br>따라서 nextList[0].seen을 변경하면 list[0].seen도 변경된다.<br>이는 state 변경이므로 반드시 주의해야 한다.<br>이를 해결하기 위해선 변경하려는 개별 항목을 변경하는 대신 복사하면 된다.<br>이에 대한 내용은 '배열 내부의 객체 업데이트하기'에 작성해놨다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "배열 내부의 객체 업데이트하기",
        "explain" : "let nextId = 3;<br>const initialList = [<br>  { id: 0, title: 'Big Bellies', seen: false },<br>  { id: 1, title: 'Lunar Landscape', seen: false },<br>  { id: 2, title: 'Terracotta Army', seen: true },<br>];<br><br>...<br><br>const [myList, setMyList] = useState(initialList);<br>const [yourList, setYourList] = useState(initialList);<br><br>...<br><br>const myNextList = [...myList];<br>const artwork = myNextList.find(a => a.id === artworkId);<br>artwork.seen = nextSeen; //기존 항목을 변경시킴<br>setMyList(myNextList);<br>  <br><mark class='gray'>위 코드를 순서대로 나열해보자면 다음과 같다.<br>1. 배열 initialList의 값을 state 변수인 myList에 얕은 복사를 한다.<br>2. myList의 모든 데이터를 변수 myNextList에 복사한다.<br>※배열이기 떄문에 엄밀히 말하자면 값을 참조하게 된다.<br>※즉, myList[0] 과 myNextList[0] 은 같은 데이터를 바라보게 된다.<br>3. myNextList의 데이터를 find함수를 사용해 가공 후 변수 artwork에 복사한다.<br>※artwork에 복사된 값은 myNextList에 있는 동일한 값의 주소를 참조하고 있는 상태이다. 결코 독립된 값이 아니다.<br>※참고로 find()와 filter()는 다르다.<br>※find()는 조건에 일치한 값들 중 처음에 발견된 한 가지만 반환한다.<br>※filter()는 조건에 일치한 값 전부를 새로운 배열로 반환한다.<br>4. 변수 artwork의 속성 seen의 값을 nextSeen의 값으로 변경한다.<br>※state set함수를 통한 것이 아닌 직접 값을 변경한 것이므로 당연히 artwork의 원래 값이 변경된다.<br>※3에 적었듯 변수 artwork에 담긴 값은 myNextList와 같은 주소를 참조하고 있다. 그러므로 artwork의 값이 변경되면 myNextList의 값도 변경된다.<br>※이를 코드로 보자면 artwork.seen = nextSeen 라는 코드는 사실상 myNextList[찾은 인덱스].seen = nextSeen 와 똑같은 효과를 낸다. myNextList 배열 내부에 있는 객체 하나의 속성이 직접 변경된 것이다.</mark><br><br>위의 코드는 아래와 같이 변경하면 된다.<br>setMyList(myList.map(artwork => {<br>    if (artwork.id === artworkId) {<br>        // 변경된 새 객체를 만들어 반환<br>        return { ...artwork, seen: nextSeen };<br>    } else {<br>        // 변경시키지 않고 반환.<br>        return artwork;<br>    }<br>}));<br><br><mark class='gray'>※쉽게 말해 useState를 사용하겠다고 명시한 변수(myList)는 반드시 set함수(setMyList)를 사용해서 값의 상태가 변경되어야 한다.<br>※반면 state와 전혀 연관없이 새롭게 생성된 객체의 경우 state의 일부가 아니므로 직접적으로 값을 추가 및 변경할 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "state 관련",
        "title" : "여러 주의사항",
        "explain" : "·State 변수가 객체인 경우엔 하나의 필드만 업데이트할 수 없다.<br>const [position, setPosition] = useState({ x: 0, y: 0 }); 가 있을 때<br>setPosition({ x: 100 }) 은 y 속성이 존재하지 않기 때문에 사용불가.<br>x만 설정하려면 setPosition({ ...position, x: 100 })을 하거나 두 개의 state 변수로 나누고 setX(100)을 해야 한다.<br><br><br>·function Message({ messageColor }) {<br>  const [color, setColor] = useState(messageColor);<br>여기서 color state 변수는 messageColor prop로 초기화된다.<br>문제는 부모 컴포넌트가 나중에 다른 값의 messageColor를 전달한다면 (예를 들어, 'blue' 대신 'red')<br>color state 변수 가 업데이트되지 않는다.<br>State는 첫 번째 렌더링 중에만 초기화되기 떄문이다.<br><br>이를 정상적으로 사용하기 위해선 messageColor prop을 상수에 대입하여 사용하면 된다.<br>function Message({ messageColor }) {<br>  const color = messageColor;<br><br>컴포넌트 함수를 중첩해서 정의하면 안되는 이유<br>export default function MyComponent() {<br>  const [counter, setCounter] = useState(0);<br><br>  function MyTextField() {<br>    const [text, setText] = useState('');<br><br>    return (<br>      &lt;input<br>        value={text}<br>        onChange={e =&gt; setText(e.target.value)}<br>      /&gt;<br>    );<br>  }<br><br>  return (<br>    &lt;&gt;<br>      &lt;MyTextField /&gt;<br>      &lt;button onClick={() =&gt; {<br>        setCounter(counter + 1)<br>      }}&gt;Clicked {counter} times&lt;/button&gt;<br>    &lt;/&gt;<br>  );<br><br>위 코드를 실행하면 인풋과 버튼이 있는데<br>인풋에 값을 입력 후 버튼을 누르는 순간 인풋의 값은 사라지고, 버튼의 counter는 하나 올라가게 된다.<br>버튼의 counter가 올라가는 이유는 갱신된 state의 값을 가져오기 때문이지만<br>인풋의 값이 사라지는 이유는 버튼을 누르는 순간 리렌더링이 이뤄지면서 <br>MyTextField 함수가 새로 생성되기 떄문이다.<br>즉, MyTextField 함수 내의 state 역시 새로 생성되는 것이기 때문에 이전의 값을 가져올 수 없다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "state 초기화 조건",
        "explain" : "·컴포넌트가 지워질 경우 해당 컴포넌트가 가지고 있던 state 값은 초기화된다.<br>이 말은 반대로 컴포넌트가 유지되는 한 state 값은 초기화 되지 않음을 뜻한다.<br>export default function App() {<br>  const [isFancy, setIsFancy] = useState(false);<br>  return (<br>    &lt;div&gt;<br>      {isFancy ? (<br>        &lt;Counter isFancy={true} /&gt;<br>      ) : (<br>        &lt;Counter isFancy={false} /&gt;<br>      )}<br><br>위 코드의 경우 isFancy가 true이든 false이든 &lt;Counter /&gt;는 같은 자리에 있기에<br>state 값은 초기화 되지 않는다.<br><br>하지만 아래의 경우는 조금 다르다<br>&lt;div&gt;<br>      {isPlayerA &&<br>        &lt;Counter person='Taylor' /&gt;<br>      }<br>      {!isPlayerA &&<br>        &lt;Counter person='Sarah' /&gt;<br>      }<br>위 코드의 경우 isPlayerA의 여부에 따라 person의 값이 다른 Counter 컴포넌트를 호출하게 된다.<br>얼핏보면 같은 위치에서 선언된 컴포넌트이기 때문에 state값이 유지될것이라 생각할 수 있지만<br>이는 조건에 따라서 조건에 맞는 컴포넌트는 호출하고, 다른 컴포넌트는 호출하지 않는 것이다.<br>즉, 기존의 위치에서 유지되는 개념이 아닌 사라지는 개념이다.<br><br>이러한 차이는 삼항연산자와 분리된 조건문(if)의 서로 다른 개념에 의해 생긴다.<br>삼항 연산자: 하나의 논리적인 렌더링 위치, 동일한 컴포넌트 타입 → State 유지<br>분리된 조건문: 두 개의 논리적인 렌더링 브랜치, 조건 변화 시 한 브랜치 언마운트/다른 브랜치 마운트 → State 초기화<br><br>삼항 연산자는 기존의 state 값을 유지하고 있으니 연동되야 하는 기능을 다룰때<br>분리된 조건문은 적은 수의 코드로 각각의 기능을 만들 수 있으니 상황에 맞게 쓰면 된다.<br><br><br>·다른 예시로<br>export default function App() {<br>  const [isFancy, setIsFancy] = useState(false);<br>  if (isFancy) {<br>    return (<br>      &lt;div&gt;<br>        &lt;Counter isFancy={true} /&gt;<br>...<br>  }<br>  return (<br>    &lt;div&gt;<br>      &lt;Counter isFancy={false} /&gt;      <br><br>위 코드의 경우<br>if가 있는경우, 없는 경우 둘 다 컴포넌트의 첫 번째 자식으로 div를 반환 후 Counter컴포넌트를 호출한다.<br>결국 같은 위치에서 호출되고 있으므로 isFancy 조건문을 타던 안타던 state는 초기화 되지 않는다.<br><br><br>·또 다른 예시로<br>export default function App() {<br>  const [isFancy, setIsFancy] = useState(false);<br>  return (<br>    &lt;div&gt;<br>      {isFancy ? (<br>        &lt;div&gt;<br>          &lt;Counter isFancy={true} /&gt;<br>        &lt;/div&gt;<br>      ) : (<br>        &lt;section&gt;<br>          &lt;Counter isFancy={false} /&gt;<br>        &lt;/section&gt;<br>      )}<br><br>위 코드의 경우 App컴포넌트의 첫번째 자식은 div로 동일하나<br>조건에 따라 후손이 div 혹은 section이다.<br>즉 Counter컴포넌트가 조건에따라 다른 위치에서 호출되므로<br>이 경우엔 state가 초기화 된다.<br>즉 리렌더링할 때 state를 유지하고 싶다면 트리 구조가 같아야 한다.<br><br><br>·key를 사용해서 state 초기화 하는 방법<br>key는 React가 컴포넌트를 구별할 수 있도록 사용할 수도 있다.<br>가본적으로 React는 컴포넌트를 구별하기 위해 부모 안에서의 순서를 이용한다.<br>그러나 key를 이용하면 특정한 순서라고 말해줄 수 있다.<br>예를 들면 key='Taylor'와 같이 말이다.<br>이렇게 트리 어디에서 해당 컴포넌트는 Taylor의 것이라는 걸 알 수 있다.<br><br>{isPlayerA ? (<br>  &lt;Counter key='Taylor' person='Taylor' /&gt;<br>) : (<br>  &lt;Counter key='Sarah' person='Sarah' /&gt;<br>)}<br><br>위와 같이 key를 명시하면 React는 부모 내에서의 순서 대신에 key 자체를 위치의 일부로 사용한다.<br>이렇게 key를 사용하게 되면 상항연산자에 있는 같은 컴포넌트라고 해도 서로 state를 공유하지 않는다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    }
]