[
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "리액트란",
        "title" : "리액트란",
        "explain" : "<mark class='gray'>React = React는 페이스북이 만든, MVC 패턴 중 V를 담당하는 사용자 인터페이스를 구축하기 위한 JavaScript 라이브러리.<br>뷰만 담당하기 때문에 M이나 C는 다른 라이브러리나 패키지로 보완해줘야 한다.<br>react와 바닐라 js로 제작된 웹 사이트의 차이는<br>바닐라 js에서는 element의 변경이 일어나면 전체를 다시 그린다.<br>하지만 react는 변경된 세부 요소만 다시 그리기에 성능적인 면에서 더욱 효율적이다.<br>※리액트는 라이브러리이기는 하지만 Redux나 MobX, react-router와 함께 프레임워크처럼 사용된다.<br>※사용자 인터페이스 = 사용자와 소프트웨어 간의 상호작용을 가능하게 하는 모든 요소를 말한다.<br>예를 들어 버튼, 텍스트 필드, 이미지 등 다양한 UI 요소를 포함한다.<br>※Redux = 상태 관리 라이브러리로, 애플리케이션의 상태를 중앙에서 관리할 수 있도록 도와준다.<br>React와 함께 사용되며, 예측 가능한 상태 관리를 가능하게 한다.<br>※react-router = React 애플리케이션에서 라우팅을 관리하는 라이브러리다.<br>사용자가 URL을 통해 애플리케이션의 다른 부분으로 이동할 수 있도록 도와준다.<br>※프레임워크 = 특정한 구조와 규칙을 제공하여 개발자가 애플리케이션을 구축할 수 있도록 돕는 소프트웨어다.<br>React는 라이브러리로 분류되지만, Redux, react-router와 함께 사용될 때 프레임워크처럼 작동할 수 있다.<br>※바닐라 JS = 기타 js 라이브러리를 사용하지 않은 순수 자바스크립트를 의미한다.<br>즉, 어떠한 프레임워크나 라이브러리를 사용하지 않고, 웹 브라우저에서 기본적으로 제공되는 js를 말한다.<br>바닐라 JS는 대규모 애플리케이션을 관리하거나 복잡한 기능을 구현하는 데는 제한적일 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "사용용도",
        "explain" : "<mark class='gray'>단일 페이지 애플리케이션(SPA)이나 웹 애플리케이션의 일부분을 개발할 때 사용되며,<br>사용자 인터페이스를 구성하는 데 있어서 재사용 가능한 UI 컴포넌트를 만들고 관리하는 데 중점을 둔다.<br>※단일 페이지 애플리케이션(SPA) = 웹 애플리케이션의 한 형태로, 페이지가 새로 고침되지 않고도 사용자와 상호작용할 수 있도록 설계된 애플리케이션이다.<br>React는 SPA를 구축하는 데 매우 적합하다.<br>※웹 애플리케이션 = 웹 브라우저를 통해 접근할 수 있는 소프트웨어 애플리케이션이다.<br>서버와 클라이언트 간의 상호작용을 통해 동적으로 콘텐츠를 제공할 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "특징",
        "explain" : "<mark class='gray'>1. 선언형<br>상호작용이 많은 UI를 만들 때 생기는 어려움을 줄여준다.<br>개발자는 애플리케이션의 각 상태에 대한 간단한 뷰만 설계하면 된다.<br>react는 데이터가 변경됨에 따라 적절한 컴포넌트만 효율적으로 갱신하고 렌더링한다.<br>선언형 뷰는 코드를 예측 가능하고 디버그하기 쉽게 만들어 준다.<br>여기서 말하는 선언이란 어떤 상태를 어떻게 표현해야 할지를 명시적으로 작성하는 것을 의미하며,<br>이로 인해 개발자가 UI의 논리를 더 쉽게 이해하고 관리할 수 있게 해준다.<br>※렌더링 (Rendering) = react의 컴포넌트가 사용자의 화면에 표시될 UI를 생성하고 브라우저에 보여주는 과정을 뜻한다.<br>유저의 이벤트 발생, 서버의 상태 변화 등에 따라 렌더링이 다시 발생한다.<br>이를 리렌더링 (re-rendering) 이라 한다.<br><br>2. 컴포넌트(component) 기반<br>상태를 관리하는 캡슐화된 컴포넌트를 만들 수 있다.<br>그리고 이를 조합해 더욱 더 복잡하고 유기적인 흐름을 가진 컴포넌트 트리를 만들 수 있다.<br>컴포넌트 로직은 템플릿이 아닌 javascript 혹은 typescript로 작성된다.<br>따라서 다양한 형식의 데이터를 앱 안에서 손쉽게 전달할 수 있고, DOM과는 별개로 상태를 관리할 수 있다.<br>DOM과는 별개로 상태를 관리할 수 있다는 의미는 가상 DOM을 사용한다는 것이다.<br>가상 DOM을 사용하기에 업데이트 빈도가 높아도 그렇게 무리가 가지 않는다.<br>DOM 조작이 브라우저에 엄청 무리를 주기 때문에 가상 DOM을 만들어 달라진 부분만 비교해 업데이트한다.<br>※컴포넌트 = 웹 사이트를 조각낸 것이며, 그 조각 하나 하나가 각자 기능하는 완성품이라고 생각하면 된다.<br>※이러한 컴포넌트는 재사용 가능한 UI의 가장 작은 단위이다. 컴포넌트는 javascript, typescript의 함수형 또는 class 형식으로 구현할 수 있다.<br>※결국 컴포넌트는 독립적으로 기능해야하며, 재사용 가능해야 한다.<br>DOM (Document Object Model)<br>※DOM = html은 계층적 구조로 되어 있기에 객체로 표현이 가능하다.<br>이렇게 HTML구조를 객체로서 표현한 것이 DOM이다.<br>웹 페이지에 새로운 요소를 추가하거나 기존 요소를 변경함으로써 웹 페이지를 동적으로 만들 수 있다.<br>※가상 DOM = 실제 DOM에서 처리하는 방식이 아닌 Virtual DOM과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화하는 프로그래밍 개념이다.<br>해당 DOM을 컴포넌트 단위로 쪼개어 HTML 컴포넌트 조립품 처럼 다루는 개념이다.<br>react가 사용하는 구조로, 실제 DOM과 동기화하여 변경된 부분만 업데이트하여 렌더링 성능을 최적화해준다.<br>※typescript = js에 정적 타입을 추가한 슈퍼셋 언어로, 마이크로소프트에서 개발하였다.<br>컴파일 시점에서 타입 오류를 체크하여 개발자의 실수를 방지하고 코드의 가독성을 높여 개발을 도와준다.<br>줄여서 ts라고도 지칭하기도 한다.<br>TypeScript로 작성된 코드는 JavaScript로 컴파일되어 실행된다.<br>※슈퍼셋 언어 = 다른 언어의 기능을 포함하면서 추가적인 기능이나 문법을 제공하는 언어를 의미한다.<br>예를 들어 TypeScript는 JavaScript의 슈퍼셋이다.<br>※정적 타입 = 변수의 데이터 타입이 컴파일 시점에 결정되는 프로그래밍 언어의 특성을 의미한다.<br>즉, 변수를 선언할 때 그 변수의 타입을 명시해야 하며, 이후에는 해당 타입에 맞는 값만 할당할 수 있다.<br>정적 타입 언어의 예로는 Java, C++, TypeScript 등이 있다.<br>정적 타입 언어의 작동 원리는 다음과 같다.<br>정적 타입 언어 = 소스코드 -> 컴파일 시작 -> 컴파일러 작동 -> 컴파일 종료 -> 사용자가 프로그램 실행 -> 런타임 실행<br>※컴파일 = 소스 코드를 기계어 또는 중간 코드로 변환하는 과정이다.<br>이 과정은 일반적으로 컴파일러라는 프로그램에 의해 수행된다.<br>컴파일된 프로그램은 실행 시점에 더 빠르게 실행될 수 있으며, 일반적으로 정적 타입 언어에서 사용된다.<br>컴파일은 프로그램 실행 전에 이루어 진다.<br>※컴파일러 = 소스 코드를 분석하고, 문법 오류를 체크한 후, 최적화된 기계어 코드로 변환하여 실행 가능한 파일을 생성한다.<br>컴파일러는 전체 소스 코드를 한 번에 기계어로 변환한다.<br>※동적 타입 = 변수의 데이터 타입이 런타임 시점에 결정되는 프로그래밍 언어의 특성을 의미한다.<br>즉, 변수를 선언할 때 타입을 명시할 필요가 없으며, 실행 중에 변수에 할당된 값에 따라 타입이 결정된다.<br>동적 타입 언어의 예로는 JavaScript, Python, Ruby 등이 있다.<br>동적 타입 언어의 작동 원리는 다음과 같다.<br>동적 타입 언어 = 소스코드 -> 인터프리터 시작 -> 인터프리트 실행 -> 인터프리터 종료 -> 사용자가 프로그램 실행 -> 런타임 실행<br>※인터프리터 (Interpreter) = 소스 코드를 한 줄씩 읽고 해석하여 실행하는 프로그램 또는 도구를 의미한다.<br>즉, 소스 코드를 기계어로 변환(컴파일)하지 않고, 실행 시점(런타임)에 직접 해석하여 실행한다.<br>※인터프리트 (Interpret) = 소스 코드를 해석하여 실행하는 과정을 설명할 때 사용.<br>※인터프리터는 소스 코드를 한 줄씩 읽고 실행하는 방식으로, 컴파일 과정이 필요하지 않다.<br>이 경우, 런타임에 타입 검사가 이루어지며, 타입 오류는 프로그램 실행 중에 발생할 수 있다.<br>인터프리터는 소스 코드를 인터프리트하여 실행한다 와 같이 말 할 수 있다.<br>※런타임 = 프로그램이 실행되는 시점을 의미한다.<br>즉, 프로그램이 컴파일된 후 실제로 사용자가 프로그램을 실행할 때의 상태를 나타낸다.<br>런타임 동안 프로그램은 메모리에 로드되고, 사용자 입력을 처리하며, 다양한 연산을 수행한다.<br><br>3. 확장성<br>react를 한번 배움으로써 다양한 부분으로 뻗어 나갈 수 있다.<br>react는 Node 서버에서 렌더링을 할 수도 있고, React Native를 이용하면 모바일 앱도 만들 수 있다.<br><br>즉, react는 가상 DOM을 활용하여 성능을 최적화하고,<br>컴포넌트 기반 아키텍처를 채택하여 재사용 가능하고 모듈화된 컴포넌트를 만들 수 있도록 도와주며,<br>선언적 프로그래밍을 통해 UI와 상태를 관리할 수 있도록 지원한다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "리액트 설치 방법",
        "title" : "CDN 사용",
        "explain" : "<mark class='gray'>아래와 같은 코드를 html - head태그 안에 입력해주면 된다.<br><textarea style='width: 97%;'><script crossorigin src='https://unpkg.com/react@18/umd/react.development.js'></script><br><script crossorigin src='https://unpkg.com/react-dom@18/umd/react-dom.development.js'></script></textarea><br><br>※react를 사용해서 웹사이트를 만들 때마다 매번 이러한 환경 설정을 해줘야 한다면 번거롭기에 이 방식은 잘 사용되지 않는다.<br>※CDN (Content Delivery Network) = CDN은 콘텐츠 전송 네트워크의 약자로,<br>전 세계에 분산된 서버를 사용하여 웹 사이트의 콘텐츠를 더 빠르게 제공하는 기술이다.<br>보통 css, js 파일, 이미지, 폰트 등의 정적 콘텐츠를 CDN을 통해 받으면 사용자가 해당 콘텐츠를 빠르게 다운로드할 수 있다.<br>사용법은 단순하게 링크를 html의 코드에 작성하면 된다.<br>이를 통해 라이브러리를 다운로드하고 호스팅하는데 드는 비용과 서버 부하를 줄일 수 있다.<br>react역시 CDN으로 로드하여 프로젝트에서 사용할 수 있지만<br>react 프로젝트를 만들 때에는 기존 html에 작성하지 않고, <br>react 프로젝트를 자동으로 세팅해주는 CRA 기능을 통해 제작한다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "CRA(create-react-app) 사용",
        "explain" : "<mark class='gray'>create-react-app은 react의 보일러 플레이트이다.<br>CDN 사용방식과는 달리 NodeJS와 Webpack 설치를 해줘야 한다.<br>CRA는 Webpack 설치 및 구현을 자동으로 해주는 편리한 기능이다. <br>때문에 CRA로 react project를 작성하는 것이 가장 많이 사용되는 방법이라고 한다.<br><br>※보일러 플레이트 = 특정 개발작업을 하기 위해 미리 준비된 환경 및 도구 세팅.<br>※NodeJs =  브라우저 환경이 아닌 곳에서도 자바스크립트를 실행할 수 있게 해주는 자바스크립트 런타임 언어.<br>※Webpack = 웹 애플리케이션의 소스 코드 및 리소스를 번들링하고 관리하기 위한 모듈 번들러.<br>※번들 = 여러 개의 프로그램, 라이브러리, 또는 모듈을 하나의 패키지로 묶은 것.<br>사용자는 이 번들을 설치함으로써 여러 개의 소프트웨어를 한 번에 설치할 수 있다.<br>예를 들어, 특정 애플리케이션을 실행하기 위해 필요한 모든 라이브러리와 종속성을 포함한 패키지를 제공하는 경우가 이에 해당한다.<br>※번들링 (Bundling) = 여러 개의 파일이나 자원을 하나의 파일로 묶는 과정.<br>여러 JavaScript 파일, CSS 파일, 이미지 등을 하나의 번들로 묶어 네트워크 요청 수를 줄이고 로딩 속도를 개선하는 데 도움을 준다.<br>번들링을 통해 애플리케이션의 성능을 최적화할 수 있습니다.<br>※모듈 (Module) = 특정 기능이나 역할을 수행하는 독립적인 코드 블록.<br>모듈은 재사용 가능하며, 다른 모듈과 결합하여 더 복잡한 애플리케이션을 구성할 수 있다.<br>JavaScript에서는 ES6 모듈 시스템을 통해 모듈을 정의하고 사용할 수 있다.<br>모듈은 코드의 가독성을 높이고 유지보수를 용이하게 합니다.<br>※모듈 번들러 (Module Bundler) = 여러 개의 모듈을 하나의 파일로 묶어주는 도구.<br>모듈 번들러는 개발자가 작성한 모듈을 분석하고, 의존성을 해결하여 최적화된 번들을 생성힌다.<br>대표적인 모듈 번들러로는 Webpack, Rollup, Parcel 등이 있다.<br>이러한 도구는 애플리케이션의 성능을 향상시키고, 배포를 간소화하는 데 도움을 준다.<br>※정리하자면 번들 = 번들링(모듈 번들러(모듈, 모듈...)) 이런 구조라고 볼 수 있다.<br><br>1) Node.js 설치(LTS버전)<br>CRA는 Node.js 환경에서 실행되므로 Node.js를 설치해야 한다.<br>※좀 더 정확히는 리액트를 사용하는 CRA, Webpack, Babel 같은 도구들이 node.js를 기반으로 만들어져 있기 때문에 node.js를 설치해야 한다.<br>Node.js를 설치하기 위해서는 공식 사이트에서 다운로드 받아 설치하면 된다.<br>( https://nodejs.org/en/ )<br>※Node.js 설치시에는 안전성을 위해 LTS버전으로 설치하면 된다.<br>※LTS(Long Term Support) = 장기 지원되는 버전을 의미한다. 일반 버전과 달리 안정성에 중점을 둔 버전으로, 보안과 버그 방면에서 최신 버전보다 안정적인 버전이다.<br><br>2) Node.js를 설치하면 자동으로 npm이 설치된다.<br>※npm(Node Package Manager) = 프로젝트에 필요한 외부 도구들의 설치를 도와준다.<br><br>3) Node.js와 npm이 정상적으로 설치되었는지 확인해본다.<br>명령프롬프트에서 아래와 같이 테스트해보면 된다.<br>npm설치 확인 = npm -v<br>node.js설치 확인 = node -v<br><br>4) 리액트 프로젝트가 위치할 폴더를 만든다.<br><br>5) CRA설치<br>명령프롬프트 또는 VS Code의 터미널을 킨 뒤 해당 폴더로 이동하여 아래의 명령어를 입력한다.<br>npx create-react-app 프로젝트명<br>※프로젝트 이름은 소문자로만 작성되어야한다. my-react-site 처럼 슬래시로 작성하는 케밥 케이스가 관례이다.<br>※위 명령어를 실행하면 react, react-dom, react-scripts, web-vitals 등의 패키지를 자동으로 설치한다.<br>※react-scripts는 내부적으로 Babel, Webpack을 사용한다.<br>※React = 컴포넌트의 생성, 상태 관리, hook 등의 핵심 기능을 제공하는 리액트 라이브러리다.<br>※react-dom = react의 컴포넌트를 실제 브라우저 DOM에 렌더링하고 관리하는 제공하는 라이브러리다.<br>※react-scripts = 리액트 애플리케이션을 빌드하고 실행하는 데 필요한 스크립트와 설정을 포함하는 패키지.<br>※web-vitals = 웹 성능 측정을 위한 라이브러리.<br>※Babel = 자바스크립트 코드를 최신 버전의 ECMAScript 문법으로 작성하고, 이를 구버전의 브라우저에서도 동작하도록 변환해주는 도구이다. 최신 js 문법을 사용하여 개발을 하면, 모든 브라우저가 해당 문법을 지원하지 않을 수 있다. Babel은 이러한 문제를 해결하기 위해 최신 문법을 구버전의 js로 변환하여 호환성을 보장해주는 역할이다.<br><br>※npx create-react-app 와 npm install -g create-react-app 의 차이 및 자세한 설명은 다음과 같다.<br>npx: Node.js의 패키지 실행 도구로, npm에 설치된 패키지를 실행할 수 있게 해준다. npx를 사용하면 패키지를 전역으로 설치하지 않고도 사용할 수 있다.<br>create-react-app: create-react-app 패키지를 사용하여 새로운 리액트 애플리케이션을 생성한다. npx는 최신 버전의 create-react-app을 자동으로 다운로드하고 실행한다.<br>장점: 항상 최신 버전의 create-react-app을 사용할 수 있으며, 전역 설치가 필요 없으므로 시스템을 깔끔하게 유지할 수 있다.<br>단점 : 전역으로 설치된 것이 아니기에 npx create-react-app 프로젝트명 을 한 프로젝트에만 적용이 된다.<br><br>npm install -g: create-react-app 패키지를 전역(global)으로 설치한다. 즉, 시스템의 모든 프로젝트에서 이 패키지를 사용할 수 있게 된다.<br>※리액트 애플리케이션의 버전은 설치받을때 당시의 최신버전이 다운받아진다.<br>create-react-app: 전역으로 설치된 후, create-react-app 명령어를 사용하여 새로운 리액트 애플리케이션을 생성할 수 있다.<br>npm install -g create-react-app 이후 create-react-app 프로젝트명1, create-react-app 프로젝트명2 를 하게되면 프로젝트1, 프로젝트2가 생성되게 되는데 이떄 두 프로젝트의 버전은 동일하다.<br>장점 : 전역으로 설치되었으므로 이후 생성하는 프로젝트는 전부 동일한 버전을 지니게 된다.<br>단점: 설치 시점의 최신버전을 다운받는다는 것은 npx와 같지만, npx는 자동으로 최신버전으로 갱신되는 반면, npm은 시간이 지나 버전이 갱신되게 되었을 때 다운받았을 때의 버전을 계속 유지하게 된다.<br>즉, 전역으로 설치된 패키지가 오래된 버전일 수 있으며, 여러 프로젝트에서 서로 다른 버전의 create-react-app을 사용할 경우 충돌이 발생할 수 있다.<br>만약 최신버전으로 재갱신하고 싶다면 npm install -g create-react-app을 다시 실행하여 최신 버전으로 업데이트해야 한다.<br>※npx create-react-app 프로젝트명 방식을 권장한다!<br><br>리액트 프로젝트 실행 : 명령프롬프트에서 리액트가 설치된 폴더로 이동 후 npm start 를 입력하면 된다.<br><br>번외) react를 ts와 함께 사용하고 싶을떄<br>npx create-react-app {프로젝트 이름} --template typescript</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "리액트 수동 설치",
        "explain" : "<mark class='gray'>CRA와는 달리 전부 수동으로 react 개발 환경을 구축하는 방법이다.<br><br>1) Node.js 설치(LTS버전)<br>CRA는 Node.js 환경에서 실행되므로 Node.js를 설치해야 한다.<br>※좀 더 정확히는 리액트를 사용하는 CRA, Webpack, Babel 같은 도구들이 node.js를 기반으로 만들어져 있기 때문에 node.js를 설치해야 한다.<br>Node.js를 설치하기 위해서는 공식 사이트에서 다운로드 받아 설치하면 된다.<br>( https://nodejs.org/en/ )<br>※Node.js 설치시에는 안전성을 위해 LTS버전으로 설치하면 된다.<br>※LTS(Long Term Support) = 장기 지원되는 버전을 의미한다. 일반 버전과 달리 안정성에 중점을 둔 버전으로, 보안과 버그 방면에서 최신 버전보다 안정적인 버전이다.<br><br>2) Node.js를 설치하면 자동으로 npm이 설치된다.<br>※npm(Node Package Manager) = 프로젝트에 필요한 외부 도구들의 설치를 도와준다.<br><br>3) Node.js와 npm이 정상적으로 설치되었는지 확인해본다.<br>명령프롬프트에서 아래와 같이 테스트해보면 된다.<br>npm설치 확인 = npm -v<br>node.js설치 확인 = node -v<br><br>4) 리액트 프로젝트가 위치할 폴더를 만든다.<br><br>5) 명령프롬프트 또는 VS Code의 터미널을 킨 뒤 4번에서 만든 폴더로 이동하여 아래의 명령어를 입력한다.<br>npm -y init<br>위 명령어를 입력하면 Node.js 프로젝트 메타데이터 파일인 package.json이 생성된다.<br>※package.json에는 프로젝트의 이름, 버전 등이 저장된다.<br>※npm init 을 입력하면 package.json의 초기 값을 사용자가 수동으로 입력할 수 있다.<br><br>6) 파일을 관리할 폴더를 만든다.<br>일반적으로 React 앱의 소스는 크게 정적 소스와 React 소스로 나뉘며, 각각의 디렉토리에 나누어 관리한다.<br>정적 소스를 저장하는 디렉토리의 이름은 public,<br>React 소스를 저장하는 디렉토리의 이름은 src가 일반적이다.<br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력한다.<br>mkdir public<br>mkdir src<br><br>7) 리액트 패키지를 설치한다.<br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력한다.<br>npm install react<br>npm install react-dom<br>※npm install react react-dom 이렇게 써도 된다.<br><br>※react 버전 확인 : npm view react version<br>※react-dom 버전 확인 : npm view react-dom version<br><br>위 명령어를 실행하면 자동으로 node_modules 디렉토리가 생성되고 내부에는 방금 설치한 패키지 및 의존성이 설치된다.<br>앞으로도 새로운 패키지를 설치하면 node_modules 디렉토리에 설치될 것이다.<br>※package-lock.json 파일도 생성되는데 이곳에는 현재 프로젝트에 설치되어 있는 패키지의 메타데이터가 저장된다.<br><br>8) 테스트를 위한 소스를 작성한다.<br>리액트 앱을 빌드하기 위한 소스에는 다음 세 가지 파일이 필수적으로 포함된다.<br>index.html : 웹페이지 요청 시 반환되는 파일<br>App.jsx : 루트 리액트 컴포넌트 파일<br>index.jsx : App.jsx를 index.html에 렌더링하는 파일<br>각각의 상세 내용은 다음과 같다.<br><br>public 디렉토리에 index.html을 작성한다.<br><textarea style='width: 97%;'><html><head><title>My react project</title></head><body><div id='root'></div><script src='main.js'></script></body></html></textarea><br><br><br>src 디렉토리에 App.jsx을 작성한다.<br><textarea style='width: 97%;'>import React from 'react';export default function App(){return (<h1>Welcome to my react project!</h1>);}</textarea><br><br><br>src 디렉토리에 index.jsx를 생성한다.<br><textarea style='width: 97%;'>import React from 'react';import { createRoot } from 'react-dom/client'; // createRoot를 가져온다.import App from './App';const root = createRoot(document.getElementById('root')); // createRoot를 사용하여 루트를 생성한다.root.render(<App />); // App 컴포넌트를 렌더링한다.</textarea><br><br>9) 컴파일을 위해 Babel을 설치한다.<br>웹브라우저는 JSX 파일을 처리할 수 없기에, Babel을 이용하여 JSX 파일을 웹브라우저가 처리할 수 있는 JS파일로 컴파일해야한다.<br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력히여 Babel을 설치한다.<br>npm install @babel/core @babel/cli @babel/preset-react --save-dev<br><br>명령프롬프트에서 4번에서 만든 폴더의 src 디렉토리 내부로 이동 후 아래의 명령어를 입력히여 Babel을 실행하여 JSX -> JS로 컴파일한다.<br>npx babel App.jsx --presets=@babel/preset-react -o App.js<br>npx babel index.jsx --presets=@babel/preset-react -o index.js<br><br>위 명령어를 실행하고 나면 src 디렉토리 내부에 JS 문법으로 컴파일된 App.js, index.js를 확인할 수 있다.<br><br>10) 번들링을 위해 webpack을 설치한다.<br>9번에서 컴파일된 JS파일은 React, ReactDOM 라이브러리에 의존하고 있으므로<br>브라우저가 웹페이지를 생성하려면 두 라이브러리의 소스까지 함께 전송해주어야 한다.<br><br>여러 개의 소스 파일을 전송할 수도 있겠지만 이는 효율적이지 못하므로<br>컴파일한 소스 파일과 라이브러리 소스파일들을 통합하여 하나의 파일로 만들어 전송하기 위해 번들링을 사용한다.<br><br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력히여 webpack을 설치한다.<br>npm install webpack webpack-cli --save-dev<br><br>명령프롬프트에서 4번에서 만든 폴더로 이동 후 아래의 명령어를 입력히여 webpack을 실행한다.<br>npx webpack<br><br>위 명령어를 실행하게 되면 <br>루드 디렉토리에 dist 디렉토리가 생성되고, 내부에는 webpack이 생성하는 JS파일의 기본 이름인 main.js가 생성되게 된다.<br>※main.js안에는 컴파일한 소스 파일과 라이브러리 소스파일들을 통합되어 있다.<br><br>11) 프로세스 자동화 (확인필요)<br>매번 코드 입력 후 컴파일, 번들링을 하는 것은 비효율적이므로 이를 자동화 시킨다.<br><br>package.json에서 아래의 스크립트를 입력한다.<br>※아래 스크립트의 홀따옴표를 따옴표로 바꿔야 한다.<br>'scripts': {<br>    'build': 'npm run compile && npm run bundling && npm run copy && npm run clean',<br>    'compile': 'npx babel src --out-dir src --presets=@babel/preset-react --extensions \\'.jsx\\'',<br>    'bundling': 'npx webpack',<br>    'copy': 'cp -r public/. dist/',<br>    'clean': 'find src -type f -name *.js -delete'<br>}<br><br>위 스크립트의 의미는 다음과 같다.<br>compile : src 디렉토리의 모든 JSX 파일을 JS 파일로 컴파일<br>bundling : 모든 리액트 소스를 하나의 파일로 번들링<br>copy : 모든 정적 파일을 dist 디렉토리에 복사<br>clean : compile 작업에서 생성된 모든 JS 파일을 삭제<br><br>위 스크립트를 입력 후 명령프름프트에서 npm run build을 실행 후<br>dist 디렉토리에 있는 모든 파일을 웹서버에 복사하면 React 앱을 서비스할 수 있다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupIng",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "CRA와 수동 설치의 차이",
        "explain" : "Create React App (CRA)로 생성한 프로젝트와 수동으로 React를 설치한 프로젝트 간의 차이점은 기본적인 프로젝트 구조와 설정에 있다.<br><br><mark class='gray'>Create React App (CRA):<br>CRA는 기본적으로 설정된 템플릿을 사용하여 프로젝트를 생성한다.<br>이 템플릿은 src 폴더에 App.js 파일을 포함하고 있으며, 이 파일은 기본적으로 React 애플리케이션의 루트 컴포넌트로 사용된다.<br>CRA는 JSX 파일을 .js 확장자로 사용하도록 설정되어 있다. <br>즉, App.js 파일에서 JSX를 사용할 수 있으며, Babel이 이를 처리하여 JavaScript로 변환한다.<br>따라서 CRA 프로젝트에서는 App.jsx 파일이 기본적으로 제공되지 않는다.</mark><br><br><mark class='gray'>수동 설치한 React 프로젝트:<br>수동으로 React를 설치한 경우, 프로젝트 구조와 파일은 사용자가 직접 설정해야 한다. <br>이 경우, App.jsx 파일을 생성하고 JSX를 사용할 수 있다. <br>수동 설치에서는 파일 확장자에 대한 제한이 없으므로, 사용자가 원하는 대로 .jsx 파일을 만들 수 있다.</mark><br><br>결론적으로, CRA는 기본적으로 App.js 파일을 제공하며, JSX를 사용할 수 있도록 설정되어 있다.<br>반면, 수동 설치한 프로젝트에서는 사용자가 직접 파일을 생성하고 설정해야 하므로, App.jsx 파일이 있을 수 있다.<br>Babel은 두 경우 모두에서 JSX를 처리할 수 있지만, CRA는 기본적으로 .js 파일을 사용하도록 설정되어 있다." ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "리액트 버전 확인 및 버전 설치",
        "explain" : "<mark class='gray'>현재 리액트 버전 확인: 프로젝트가 설치된 디렉토리에서 다음 명령어를 실행한다.<br>npm list react<br><br>원하는 버전으로 변경: 프로젝트가 설치된 디렉토리에서 다음 명령어를 실행한다.<br>※아래의 예시는 리액트 및 리액트 도메인을 16.8.0버전으로 변경하는 것이다.<br>npm install react@16.8.0 react-dom@16.8.0</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "CRA설치 시 중요 폴더 및 파일 설명",
        "explain" : "<mark class='gray'>node-modules 폴더 :<br>node js와 관련된 패키지 및 파일들이 구성되어있는 폴더이다. 개발자들은 이 폴더를 수동으로 작업할 일이 거의 없다.<br><br>public 폴더 :<br>rendering이 진행되는 단 하나의 html 파일과, 이미지 파일이 저장되는 폴더이다.<br><br>src 폴더 :<br>react와 관련된 컴포넌트와 컴포넌트 모여 하나의 트리로 합쳐지는 root file, 추가 라이브러리 기능들이 위치하는 폴더이다. 개발자들은 대부분 이 폴더내에서 작업을 진행한다.<br><br>src/App.jsx :<br>project에서 만들어진 react 컴포넌트들이 총합되어 모이는 root 컴포넌트이다. 이곳에서 각 페이지 경로마다 렌더링될 react router를 지정하기도 한다.<br><br>src/index.jsx :<br>App.jsx에서 합쳐진 컴포넌트들을 ReactDOM을 통해 브라우저에 렌더링하는 역할을 한다.<br><br>package.json :<br>react의 버전, 추가적으로 설치한 기타 라이브러리들의 버전, npm 명령어들을 관리하는 파일이다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "컴포넌트 및 엘리먼트",
        "explain" : "<mark class='gray'>리액트는 컴포넌트로 구성된다.<br>컴포넌트 = 고유한 로직과 모양을 가진 UI.</mark><br>※컴포넌트는 그 용도에 따라 아주 작은 버튼이 될 수도 있고, 전체 페이지만큼 클 수도 있다.<br><br>리액트 컴포넌트는 최종적으로 HTML로 변환되는 JSX를 반환하는 자바스크립트 함수를 뜻한다.<br><mark class='gray'>리액트 컴포넌트 선언 = function 함수명() { return (JSX문법); }<br>리액트 컴포넌트 호출 = <함수명 /><br>※리액트 컴포넌트는 마치 생성자와 같이 대문자로 시작해야 하며, JSX문법에서 쓰이는 html태그는 소문자로 시작해야 한다.<br>※리액트 컴포넌트는 중첩이 가능하다.<br><br><br>엘리먼트 = react의 기본 단위로, 컴포넌트의 가장 작은 부분을 의미한다. JSX 혹은 TSX를 사용하여 정의하며, react 엘리먼트는 가상 DOM을 생성한다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='ByaRQyj' data-pen-title='컴포넌트' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/ByaRQyj'><br>컴포넌트</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "JSX",
        "title" : "JSX란",
        "explain" : "<mark class='gray'>JSX는 JavaScript XML의 약자로, react에서 사용되는 문법 확장이다.<br>js의 확장 문법이기에 js의 기본 기능이 포함되어 있다.<br>JSX는 react 컴포넌트를 만들 때 사용</mark>되며, XML과 비슷한 문법으로 UI 컴포넌트를 정의할 수 있게 해준다.<br>JSX는 보다 가독성이 높고, 코드를 작성하는데 편의성을 제공한다.<br>하지만 <mark class='gray'>브라우저에서는 바로 실행할 수 없으므로 Babel과 같은 도구를 사용하여 일반 자바스크립트로 변환되어야 한다.</mark><br>※jsx는 웹 공격을 안전하게 막아준다. 모든 항목은 렌더링 되기 전에 문자열로 변환되기특성으로 인해 웹 공격으로 부터 안전하게 막아준다.<br><br><mark class='gray'>JSX는 HTML과 유사하지만, 실제로는 React.createElement 함수로 변환되어 Virtual DOM element를 생성한다.<br>이후 이것은 react의 비교 알고리즘에 의해 실제 DOM 업데이트에 활용된다.</mark><br>※컴포넌트를 만들 때, 굳이 jsx형태로 리엑트를 하지 않아도 된다.<br>React.createElement(태그, 속성, 값) 으로 작성할 수 있다.<br>하지만 일반적으로 jsx문법으로 작성하며, jsx 작성법이 더 간결하고 가독성이 뛰어나다.<br>※typeScript에서는 tsx를 사용한다.<br>※tsx : typeScript를 사용하여 작성된 react 컴포넌트의 확장자를 나타내는 것으로, js 코드에 타입 정보를 포함할 수 있는 기능을 제공한다. typeScript 전용의 jsx라고 볼 수 있다.<br>※tsx 파일 역시 Babel과 같은 도구를 사용하여 일반 js로 변환되며, ts 전용 컴파일러를 통해 타입 검사 및 변환 작업이 추가적으로 수행된다.<br><br><mark class='gray'>버튼의 렌더링 로직과 버튼의 마크업이 함께 있으면, 매번 변화가 생길 때마다 서로 동기화 상태를 유지할 수 있다.</mark> <br>반대로 버튼의 마크업과 사이드바의 마크업처럼 서로 관련이 없는 항목들은 서로 분리되어 있으므로,각각 개별적으로 변경하는 것이 더 안전하다.<br><mark class='gray'>※렌더링 로직 =  컴포넌트가 어떻게 화면에 나타날지를 결정하는 코드를 뜻한다.<br>※예를 들어, 버튼이 클릭되었을 때 어떤 상태가 변화하고, 그에 따라 버튼의 스타일이나 텍스트가 어떻게 변하는지를 설정하는 부분이다.<br>※동기화 상태 = 상태 변화(예: 버튼 클릭)에 따라 마크업이 즉시 업데이트됨으로써 버튼의 상태와 시각적 표현이 항상 일치하게 유지된다.</mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "JSX 사용법",
        "explain" : "<mark class='gray'>1. 하나의 루트 엘리먼트로 반환하기 <br>하나의 컴포넌트에서 하나의 엘리먼트를 반환하려면 그냥 반환하면 되지만<br>하나의 컴포넌트에서 여러 엘리먼트를 반환하려면, 하나의 부모 태그로 감싸야 한다.<br>예를 들어 &lt;div&gt;...&lt;/div&gt; 또는 빈 &lt;&gt;...&lt;/&gt; 래퍼와 같이 전체 JSX가 공유하는 부모로 감싸야 한다.<br>※이러한 것을 루트 엘리먼트로 감싼다고 하다.<br>※빈 &lt;&gt;...&lt;/&gt; 을 Fragment라고 한다.<br>※Fragment는 브라우저상의 HTML 트리 구조에서 흔적을 남기지 않고 그룹화해준다.<br><br>2. 모든 태그는 반드시 닫아야 한다.<br>JSX에서는 &lt;br /&gt;같이 태그를 반드시 닫아야한다.<br><br>3. 캐멀 케이스로 작성한다.<br>stroke-width 대신 strokeWidth로 사용한다.<br>또한 class는 예약어이기 때문에, className으로 사용한다.<br>※aria-*와 data-*의 어트리뷰트는 HTML에서와 동일하게 대시를 사용하여 작성한다.<br><br>※아래의 예시에는 return( JSX문법 ) 이런식으로 사용했지만, JSX문법을 return문 안에서만 쓸 수 있는건 아니다.<br>※return() 은 순수 javascript에서도 쓸 수 있다. 주로 가독성을 위해 여러 줄의 값을 반환할 때 사용된다.※JSX 내에서 JavaScript 표현식(예를 들어 map)을 사용할 때는 항상 중괄호 {}로 감싸야 한다.<br>JSX 문법 내에서는 for문 사용이 불가능하다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='mydmOpV' data-pen-title='JSX' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/mydmOpV'><br>JSX</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "export",
        "explain" : "export default = JavaScript 모듈 시스템에서 사용되는 구문.<br><mark class='gray'>특정 모듈에서 기본적으로 내보내고자 하는 값을 지정하는 데 사용된다.<br>이 구문을 사용하면 해당 모듈을 가져오는 다른 파일에서 이 값을 쉽게 가져올 수 있다.<br><br>※export default 는 하나의 파일에서 한번만 선언을 할 수 있다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='wBvdoZr' data-pen-title='export default' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br>  <span>See the Pen <a href='https://codepen.io/scrimer/pen/wBvdoZr'><br>  export default</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>  on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "class 속성",
        "explain" : "<mark class='gray'>리액트에서는 태그의 클래스 속성을 명시할 때 class로 쓰지 않고, className으로 쓴다.<br>※만약 class로 쓰게되면 에러가 발생하게 된다.<br>※className으로 코드를 작성 후 결과를 개발자도구로 보게되면 class로 변환되어 있는 걸 확인할 수 있다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='YPzVOdR' data-pen-title='class 속성' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/YPzVOdR'><br>class 속성</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "JSX문법 내 변수 값 노출 및 객체 정의",
        "explain" : "<mark class='gray'>JSX를 사용하면 JavaScript 파일에 HTML과 비슷한 마크업을 작성할 수 있어 렌더링 로직과 콘텐츠를 같은 곳에 둘 수 있다.<br>또한 마크업 내부에 JavaScript 로직을 추가하거나 동적인 프로퍼티를 참조할 수 있다.<br>이를 위해 JSX에서 중괄호를 사용하여 사용할 수 있다.<br><br>아래는 JSX안에서 JavaScript를 사용하는 방법에 대한 간략한 설명이다.<br><br>1. 따옴표로 문자열 전달 = &lt;img className='문자열'/&gt;<br>※문자열을 작은따옴표나 큰따옴표로 감싸주면 된다.<br><br>2. 속성 값을 동적으로 지정<br>conat asd = '문자열';<br>&lt;img className= {asd}/&gt;<br>※{asd}는 변수 그 자체를 전달하지만 '{asd}'는 '{asd}'이라는 문자열을 전달하는 거다.<br>마치 1번처럼 말이다.<br><br>3. 값을 동적으로 지정<br>conat asd = '문자열';<br>&lt;h1&gt;{asd}입니다.&lt;/h1&gt;<br><br>4. 함수 그 자체를 동적으로 지정<br>const today = new Date();<br><br>function formatDate(date) {<br>  return new Intl.DateTimeFormat(<br>    'en-US',<br>    { weekday: 'long' }<br>  ).format(date);<br>}<br><br>export default function TodoList() {<br>  return (<br>    &lt;h1&gt;To Do List for {formatDate(today)}&lt;/h1&gt;<br>  );<br>}<br><br>5. 객체의 속성을 동적으로 지정<br>const asd = {<br>  a: 'aaaa',<br>  b: {<br>    b1: 'black',<br>    b2: 'pink'<br>  }<br>};<br><br>export default function TodoList() {<br>  return (<br>    &lt;div style={asd.b}&gt;<br>      &lt;h1&gt;{asd.a}'s Todos&lt;/h1&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>6. style 속성을 동적으로 지정<br>※style 속성과 같이 여러개의 속성 값이 정의 될 수 있는 경우 중괄호를 두 번 써야한다.<br><br>JSX문법 내 style 속성 값으로 변수 사용법 : {{속성키 : 속성값, 속성키 : 속성값}}<br>※위 예시를 상세히 파악하자면 다음과 같다.<br>※첫 번째 중괄호 {}: JSX에서 JavaScript 표현식을 사용하기 위해 필요하다. 이 중괄호는 JSX가 JavaScript 코드를 인식하도록 한다.<br>※두 번째 중괄호 {}: 이 부분은 실제 JavaScript 객체를 나타낸다. 객체는 {}로 감싸진 속성과 값을 키:값 으로 정의한 것이다.</mark><br>※속성키의 경우 카멜케이스로 적어야 한다. 예를 들어 기존 html에서 &lt;ul style='background-color: black'&gt;이라고 썼다면<br>&nbsp;리액트에서는 &lt;ul style={{ backgroundColor: 'black' }}&gt; 로 써야한다.<br><br>결론적으로 단순히 변수 값을 노출할 때는 중괄호를 한 쌍만 쓰면 되지만,<br>객체를 선언해야 할 때는 중괄호를 두 쌍을 써야 한다.<br>※오해하면 안되는게 JSX문법 내에서만 {객체변수명.속성키}를 쓰는 거지, JSX문법이 없는 곳에서는 javascript와 같이 객체변수명.속성키를 쓰면 된다." ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='qEBmJpv' data-pen-title='Untitled' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/qEBmJpv'><br>Untitled</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "속성(props)",
        "explain" : "<mark class='gray'>props(=properties)는 JSX 태그에 전달하는 데이터이자, 컴포넌트 간에 데이터를 전달하기 위해 props 를 사용한다.<br>모든 부모 컴포넌트는 자식 컴포넌트에 props를 제공하여 정보를 전달할 수 있다.<br>Props는 객체, 배열, 함수를 포함한 모든 JavaScript 값이 전달될 수 있으며, JSX도 가능하다.<br>props는 컴포넌트에 대한 유일한 인자이다!<br>또한 props의 값이 지정되지 않았을 때 기본값을 지정해주는 것도 가능하다.<br><br><br>1. 내부에서 porps사용법<br>※이는 'JSX문법 내 변수 값 노출 및 객체 정의'에서 다뤘던 내용이기도 하다.<br>function Asd() {<br>    const 변수1 = 값;<br>    const 변수2 = 값;<br>    return(<br>        &lt;div&gt;<br>        {변수1}<br>        {변수2}<br>        {변수1 + 변수2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>2. 부모 컴포넌트로부터 props로 전달받기 (구조 분해 할당 방식)<br>※아래의 예시에서 눈여겨 봐야 할 부분은 Child( {전달할props명1, 전달할props명2} ) 와 같이 파라미터부분에 중괄호로 props를 보낸다는 부분이다.<br>※{전달할props명1, 전달할props명2} 이렇게 props를 세분화해서 보내는 방식을 구조 분해 할당 방식이라고 한다.<br><br>function Parent() {<br>    const 변수1 = 값;<br>    const 변수2 = 값;<br>    return(<br>        &lt;Child 전달할props명1={변수1} 전달할props명2={변수2} /&gt;<br>    );<br>}<br><br>function Child( {전달할props명1, 전달할props명2} ) {<br>    return(<br>        &lt;div&gt;<br>        {전달할props명1}<br>        {전달할props명2}<br>        {전달할props명1 + 전달할props명2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>3. 부모 컴포넌트로부터 props로 전달받기 (객체로 보내기)<br>function Parent() {<br>    const 변수 = {<br>        변수1 : 값,<br>        변수2 : 값<br>    };<br>    return(<br>        &lt;Child 전달할props명={변수} /&gt;<br>    );<br>}<br><br>function Child( {전달할props명} ) {<br>    return(<br>        &lt;div&gt;<br>        {전달할props명.변수1}<br>        {전달할props명.변수2}<br>        {전달할props명.변수1 + 전달할props명.변수2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>4. spread 문법으로 props 전달하기<br>※아래의 예시에서 눈 여겨 볼 부분은 {...전달할props명} 이다.<br>※위와 같은 것을 spread 문법이라 하기도 하고 전개 연산자라고 하기도 한다.<br>※spread 문법을 사용하면 GrandParent컴포넌트로부터 props를 전달받은 Parent컴포넌트가 <br>Child 컴포넌트에게 props를 전달할 떄 구조 분해 할당 방식으로 보내게 되어 function Child( {변수1, 변수2} ) 과 같이 사용할 수 있게 해준다.<br>※객체로 props를 그룹화 하여 전달하는 방식과 spread 문법으로 props를 전달하는 방식의 가장 큰 차이점은 다음과 같다.<br>객체로 props를 그룹화 하여 전달하는 방식 = 변수명.객체 로 접근해야 한다.<br>spread 문법으로 props를 전달하는 방식 = 객체 로 접근해야 한다.<br><br>function GrandParent() {<br>    const 변수 = {<br>        변수1 : 값;<br>        변수2 : 값;<br>    };<br>    return(<br>        &lt;Parent 전달할props명={변수} /&gt;<br>    );<br>}<br><br>function Parent( {전달할props명} ) {<br>    return(<br>        &lt;Child {...전달할props명} /&gt;<br>    );<br>}<br><br>function Child( {변수1, 변수2} ) {<br>    return(<br>        &lt;div&gt;<br>        {변수1}<br>        {변수2}<br>        {변수1 + 변수2}<br>        &lt;/div&gt;<br>    );<br>}<br><br><br>5. 자식을 JSX로 전달하기<br>부모 컴포넌트 안에 자식 컴포넌트가 중첩되어 있는 경우 부모 컴포넌트는 자식 컴포넌트에 대한 정보를 children 이라는 props로 받을 수 있다.<br>※children은 className과 같이 예약어이다. 반드시 children을 써야 한다.<br><br>function Comp({test, children }) {<br>  return (<br>    &lt;&gt;<br>    &lt;div className='card'&gt;<br>      {children}    //ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ<br>    &lt;/div&gt;<br>    &lt;span&gt;{test}&lt;/span&gt; //777<br>    &lt;/&gt;<br>  );<br>}<br><br>export default function Main() {<br>  return (<br>    &lt;Comp test={'777'}&gt;<br>      ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ<br>    &lt;/Comp&gt;<br>  );<br>}<br><br><br>6. props 기본값 지정하기<br>※전달할props명2 = 100 부분이 기본값을 지정한 부분이다.<br>※기본값은 전달할props명2 이 없거나 전달할props명2={undefined}로 전달될 때 사용된다.<br>※그러나 전달할props명2={null} 또는 전달할props명2={0}으로 전달된다면, 기본값은 사용되지 않는다.<br>※즉, 초기화가 되지 않은 값인 경우에는 기본값이 적용될 수 있으나 모종의 이유로 값 자체가 null이나 0이 들어온 경우엔 기본값이 세팅되지 않는다는 것이다.<br><br>function Asd( {전달할props명1, 전달할props명2 = 100} ) {  <br>}<br></mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='pvoLOee' data-pen-title='props' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/pvoLOee'><br>props</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "조건부 렌더링",
        "explain" : "<mark class='gray'>if 또는 삼항연산자 등을 통하여 조건에 따라 렌더링이 가능하게 할 수 있다.<br>※JSX문법 밖에서는 if, &&, 삼항연산자 전부 쓸 수 있지만 JSX문법 내에서는 if는 쓸 수 없다.<br>※각각의 컴포넌트는 반드시 무언가를 반환해야 하는데 조건에 따라 아무런 JSX도 반환하지 않아야 한다면 return null을 사용할 수 있다.<br><br>조금 헷갈리는 내용이 있어서 적는다.<br>function Asd() {<br>    const branch = true;<br>    const name = '777';<br>    return(<br>        &lt;div&gt;<br>        예시 1<br>        {branch ? name + '9' : name}<br><br>        예시 2<br>        {branch ? &lt;s&gt;{name + '9'}&lt;/s&gt; : name}<br><br>        예시 3<br>        {branch ? &lt;s&gt;{name + '9'}&lt;b&gt;{name + '7'}&lt;/b&gt;&lt;/s&gt; : name}<br><br>        예시 4<br>        {name}<br><br>        예시 5<br>        {branch ? &lt;s&gt;{name + '9'}{branch ? &lt;i&gt;{name}&lt;/i&gt; : name}&lt;/s&gt; : name}<br><br>        예시 6<br>        {name} {branch && '9'}<br>        &lt;/div&gt;<br>    );<br>}<br>위 코드에서 공통적으로 쓰인 {branch ? ...} 부분은 조건부 렌더링(javascript 문법)을 쓰기 위해 중괄호가 감싸진다.<br>여기서 예시 1의 경우 이미 조건부 렌더링을 통해 중괄호로 쌓여있으니 변수를 노출할때 name + '9' 와 같이 바로 변수명을 노출해주면 된다.<br>반면 예시 2의 경우 &lt;s&gt; 태그라는 JSX문법이 또 쓰이게 되므로 그 안에서 변수를 쓰기위해선 {name + '9'} 이렇게 중괄호로 감싸져야 한다.<br>또 다른 특이한 케이스로 예시 6의 경우 branch && '9'에서 branch가 true면 '9'라는 값을 반환한다.<br>만약 branch가 false라면 아무런 값도 반환하지 않게 된다.<br>※&&의 왼쪽에 숫자를 두면 안된다.JavaScript는 자동으로 왼쪽을 부울로 변환하기 떄문에 왼쪽이 0이면 리액트는 0을 렌더링하게 된다.<br>※즉, messageCount && &lt;p&gt;New messages&lt;/p&gt; 가 아닌 messageCount &gt; 0 && &lt;p&gt;New messages&lt;/p&gt; 처럼 써야 한다는 것이다.<br><br>이를 글로써 정리해보자면 아래와 같다.<br>1. JSX문법 내에서 변수를 사용하기 위해선 {변수} 로 사용한다.<br>2. JSX문법 내에서 조건부 렌더링을 사용하기 위해선 {조건부 렌더링} 으로 사용한다.<br>3. 조건부 렌더링 내에서 변수를 사용할 때는 이미 중괄호로 감싸진 상태이므로 중괄호 없이 변수명을 쓰면 된다.<br>4. 조건부 렌더링 내에서 JSX문법이 들어가게되고 그 안에 변수가 사용될 때는 {변수} 로 사용한다.<br>5. JSX문법의 태그(예를 들어 b태그나 i태그)등이 중첩되어 있더라도 같은 JSX문법 내이므로 {{변수}} 가 아닌 {변수}로 쓰인다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='emYWoWz' data-pen-title='조건부 렌더링' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/emYWoWz'><br>조건부 렌더링</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "리스트 렌더링",
        "explain" : "<mark class='gray'>컴포넌트 리스트를 렌더링하기 위해서는 for 문 및 map() 함수와 같은 자바스크립트 기능을 사용해야 한다.<br>여기서 주의할 점은 map()은 JSX 문법내에서 사용이 가능하지만 for문은 JSX문법 내에서는 사용이 불가능하다는 것이다.<br><br>JSX 내에서 map() 사용 : {변수.map((item, index) =&gt; (로직))}<br>※(item, index) 라고 적힌 부분은 그 명칭을 달리 할 수 있다.<br>※만약 item만 쓰고 싶은 경우에는 {변수.map(item =&gt; (로직))} 으로 사용할 수 있다.<br>※반드시 JSX 내에서 map() 사용에 적은 것처럼 중괄호가 있어야 한다.<br>※그 이유는 JSX 내에서 JavaScript 표현식(예를 들어 map)을 사용할 때는 항상 중괄호 {}로 감싸야 하기 떄문이다.<br><br>JSX 내에서 filter() 사용 : 새로운 변수 = {필터링 할 변수.filter(item =&gt; (item == '값'))}<br>※다른 기능도 마찬가지지만 filter와 map을 붙여서 사용할 수 있다.<br>※새로운 변수 = 기존 변수.filter(data =&gt; data.값 == 값).map((item, index) =&gt; 로직)<br><br>※화살표 함수는 암시적으로 =&gt; 바로 뒤에 식을 반환하기 때문에 return 문이 필요하지 않다.<br>※예시 : const listItems = chemists.map(person =&gt; &lt;li&gt;...&lt;/li&gt; // 암시적 반환! );<br>※하지만 =&gt; 뒤에 중괄호가 오는 경우 return을 명시적으로 작성해야 한다.<br>※예시 : const listItems = chemists.map(person =&gt; { // 중괄호 return &lt;li&gt;...&lt;/li&gt;; });<br>※중괄호를 표현하는 화살표 함수를 “block body”를 가지고 있다고 말한다.<br>※이 함수를 사용하면 한 줄 이상의 코드를 작성할 수 있지만 return 문을 반드시 작성해야 한다. <br>※그렇지 않으면 아무것도 반환되지 않는다.<br><br>리액트에서는 key속성이 있다.<br>key속성은 리스트를 렌더링할 때 각 요소를 고유하게 식별하기 위해 사용된다.<br>※key속성은 임의의 명칭이 아닌 고정된 명칭이다.<br>Key를 사용하면 리스트가 변경되더라도 React가 각 항목의 위치를 추적할 수 있다.<br>key속성은 리액트 내부 알고리즘에서 사용되며, 실제 DOM요소에는 나타나지 않는다.<br>따라서 key속성을 입력했으나 개발자 도구에서 해당 태그에 key 속성이 보이지 않는 것은 정상적인 동작이다.<br>※map() 호출 내부의 JSX 엘리먼트에는 항상 key가 필요하다.<br>※일반적으로 데이터베이스에서 가져온 ID를 key로 사용하게 될 것이다.<br><br>※key는 변경되어서는 안 되므로 렌더링 중에는 key를 생성하지 않아야 한다.<br>※잘못된 예시1 : <br>{items.map((item, index) =&gt; (<br>    // 잘못된 예: 인덱스를 key로 사용 (변경될 수 있음)<br>    &lt;li key={index}&gt;{item}&lt;/li&gt;<br>))}<br>※위의 예시에서 index를 key로 사용하면, 리스트의 순서가 변경될 때마다 key가 변경될 수 있다. 이는 React가 요소를 올바르게 인식하지 못하게 만들 수 있다.<br><br>※잘못된 예시2 : <br>{items.map((item) =&gt; (<br>    &lt;li key={Math.random()}&gt;{item.name}&lt;/li&gt;<br>))}<br>※key={Math.random()}처럼 즉석에서 key를 생성하면 안된다.<br>※위와 같이 하면 렌더링 간에 key가 일치하지 않아 모든 컴포넌트와 DOM이 매번 다시 생성될 수 있다.<br>※이는 속도가 느려질 뿐만 아니라 리스트 항목 내부의 모든 사용자의 입력도 손실된다.<br><br>※올바른 예시 : <br>{items.map((item) =&gt; (<br>    // 올바른 예: 고유한 id를 key로 사용<br>    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;<br>))}<br><br>※key를 작성 시 짧은 &lt;&gt; &lt;/&gt; fragment 구문으로는 key를 전달할 수 없으므로 key를 단일 &lt;div&gt;로 그룹화하거나 약간 더 길고 명시적인 &lt;Fragment&gt; 문법을 사용해야 한다.<br>※예시 : <br>const listItems = people.map(person =&gt;<br>  &lt;Fragment key={person.id}&gt;<br>    &lt;h1&gt;{person.name}&lt;/h1&gt;<br>    &lt;p&gt;{person.bio}&lt;/p&gt;<br>  &lt;/Fragment&gt;<br>);<br>※Fragment는 DOM에서 사라지므로 위 예시 대로라면 &lt;h1&gt;, &lt;p&gt;, &lt;h1&gt;, &lt;p&gt; 등의 평평한 리스트가 생성된다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='zxYwQOp' data-pen-title='리스트 렌더링' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/zxYwQOp'><br>리스트 렌더링</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "컴포넌트 순수하게 유지",
        "explain" : "컴포넌트를 순수하게 유지한다는 것은 <mark class='gray'>함수형 프로그래밍을 지향</mark>한다는 의미이다.<br><mark class='gray'>함수형 프로그래밍을 지향하는 이유는 코드가 길어져도 예상밖의 동작 및 버그를 피할 수 있기 떄문이다.</mark><br><br><mark class='gray'><br>함수형 프로그래밍을 하기 위해서는 다음과 같은 규칙을 지켜야 한다.<br>1. 함수가 같은 파라미터를 받았을 때, 같은 return 값이 나와야 한다.<br>2. 함수가 호출되기 전 존재했던 변수의 데이터는 절대 훼손되서는 안된다.<br>-> 즉, 외부에 선언된 변수의 데이터는 절대 변경되면 안된다는 것이며, 반대로 함수 내부에 선언된 변수의 데이터의 경우 같은 렌더링 동안 생성된 것이기 때문에 변경되어도 괜찮다.<br>-> 이렇게 내부에서 생성되고, 변경되는 것을 지역 변경이라고 한다.<br></mark><br><br>또한 이벤트 핸들러가 컴포넌트 내부에 정의되었다 하더라도 렌더링 중에는 실행되지 않으므로 이벤트 핸들러는 순수할 필요가 없다." ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='NPWELXY' data-pen-title='컴포넌트 순수하게 유지' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/NPWELXY'><br>컴포넌트 순수하게 유지</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "groupStart",
        "reStudy" : "",
        "mainTitle" : "이벤트 핸들러",
        "title" : "이벤트 핸들러 추가",
        "explain" : "<mark class='gray'>이벤트 핸들러 함수는 다음과 같은 특징을 가지고 있다.<br>1. 주로 컴포넌트 내부에서 정의된다.<br>2. handle로 시작하고 그 뒤에 이벤트명을 붙인 함수명을 가진다.<br>(ex : onClick={handleClick}, onMouseEnter={handleMouseEnter})<br>※이벤트명을 붙인 함수는 코드상의 이슈때문이 아닌 편의성을 위함이다.<br><br><br>이벤트 핸들러를 추가하기 위한 방법은 크게 4가지가 있다.<br>1. 인라인 스타일로 정의하기 - 함수 표현식<br>&lt;button onClick={function handleClick() {<br>  alert('You clicked me!');<br>}}&gt;<br><br>2. 인라인 스타일로 정의하기 - 화살표 함수<br>&lt;button onClick={() =&gt; {<br>  alert('You clicked me!');<br>}}&gt;<br><br>3. 이벤트 핸들러 내에서 Prop 읽기 <br>function BtnComp({msg, children}) {<br>  return(<br>    &lt;button onClick={() =&gt; alert(msg)} &gt;<br>    {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>function Asd() {<br>  return(<br>    &lt;BtnComp msg='!!!'&gt;<br>    버튼을 클릭하세요.<br>    &lt;/BtnComp&gt;<br>  );<br>}<br><br>4. 이벤트 핸들러를 Prop으로 전달하기<br>// 1) 컴포넌트 생성<br>function Asd() {<br>    // 2) 이벤트 함수 선언 및 내부 로직 작성 <br>    function handleClick() {<br>        alert('You clicked me!');<br>    }<br>    return(<br>        // 3) 이벤트 핸들러를 추가 및 2)에서 선언한 이벤트 함수 props로 전달받기<br>        &lt;button onClick={handleClick}&gt;AAA&lt;/button&gt;<br>    );<br>}<br><br>5. 이벤트 핸들러 Prop 명명하기 <br>&lt;button&gt;과 &lt;div&gt; 같은 빌트인 컴포넌트는 onClick과 같은 브라우저 이벤트 이름 만을 지원한다.<br>그러나 사용자 정의 컴포넌트에서는 이벤트 핸들러 prop의 이름을 원하는 대로 명명할 수 있다.<br>※관습적으로 이벤트 핸들러 prop의 이름은 on으로 시작하여 대문자 영문으로 이어진다.<br>※아래의 예시에서 이벤트 핸들러 Prop 명명한 부분은 사용자 정의 컴포넌트인 Button에서 쓰인 onMsg이다.<br>function Button({onMsg, children}) {<br>  return(<br>    &lt;button onClick={onMsg}&gt;<br>    {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>function Asd() {<br>  return(<br>    &lt;Button onMsg={() =&gt; alert('!!!!!!!!')}<br>    btn 1<br>    &lt;/Button&gt;<br><br>    &lt;Button onMsg={() =&gt; alert('@@@@@@@@@')}<br>    btn 2<br>    &lt;/Button&gt;<br>  );<br>}</mark><br><br>※굳이 사용할려면 리액트 프로젝트에서도 addEventListener를 쓸 수 있지만, 리액트가 내부적으로 addEventListener를 사용하여 이벤트를 처리하므로 굳이 쓸 필요는 없다.<br><br><br>여기서 한가지 주의할 점은 html의 경우 &lt;button onClick=이벤트 함수명()&gt; 으로 사용하지만<br>리액트에서는 () 없이 &lt;button onClick={이벤트 함수명}&gt; 으로 사용한다는 것이다.<br><br>이에 대해 보다 자세히 설명하자면 아래와 같다.<br>&lt;button onClick=함수명()&gt; 또는 &lt;button onClick={alert('!!!')}&gt;<br>의 경우 버튼이 렌더링 될 때, 함수명()을 통해 함수를 호출했으니 결과는 발생한 상태이지만,<br>브라우저의 이벤트루프로 인해 그 결과가 사용자에게 노출되지 않은 상태이며, <br>사용자가 해당 이벤트를 실행하면 그때 그 결과를 노출해 준다.<br><br>&lt;button onClick={함수명}&gt; 또는 &lt;button onClick={() =&gt; alert('!!!')}&gt;<br>의 경우 리액트에서 자동으로 이벤트리스너를 등록한다.<br>이는 AddEventListener('click', 함수명) 과 동일하다.<br>함수명()이 아닌 함수명 이기 때문에 함수를 호출한 것이 아닌, <br>함수를 참조하고 있는 것이며 이는 콜백이기 때문에 결과는 발생하지 않은 상태이다.<br>이후 사용자가 이벤트를 실행하면 그때 콜백을 통해 해당 함수가 실행되고,<br>사용자에게 그 결과가 노출된다.<br><br>결국 위의 <br><br>이하는 좀 TMI이지만 궁금증 해소를 위해 적는다.<br>성능적인 측면에서 위의 두 방식은 각각의 장단점을 갖는다. 이를 간단히 적자면 다음과 같다.<br>&lt;button onClick=함수명()&gt;<br>장점 : 최초 렌더링 시 결과를 지니고, 사용자가 이벤트를 실행할 때마다 저장된 결과를 노출하기만 하면 되므로 이벤트가 자주 발생해도 부담이 덜하다.<br>단점 : 렌더링이 자주 일어나게 되면, 불필요한 연산이 일어나게 된다.<br><br>&lt;button onClick={함수명}&gt;<br>장점 : 사용자가 이벤트를 실행할 때만 결과가 노출되므로 렌더링이 자주 일어나도 문제가 없다.<br>단점 : 사용자가 이벤트를 자주 실행하게 되면, 이벤트 실행 시마다 결과를 연산하고, 노출해야 하므로 성능 저하가 생길 수 있다." ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='gbORgGR' data-pen-title='이벤트에 응답' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/gbORgGR'><br>이벤트에 응답</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "groupEnd",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "이벤트 전파",
        "explain" : "<mark class='gray><br>부모 컴포넌트가 자식 컴포넌트의 이벤트를 전파받는걸 뜻한다.<br><br>1. 이벤트 전파<br>function Toolbar() {<br>  return (<br>    &lt;div onClick={() =&gt; {<br>      alert('You clicked!');<br>    }}&gt;<br>      &lt;button onClick={() =&gt; alert('Playing!')}&gt;<br>        Play Movie<br>      &lt;/button&gt;<br>      &lt;button onClick={() =&gt; alert('Uploading!')}&gt;<br>        Upload Image<br>      &lt;/button&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>위 컴포넌트에서 Play Movie버튼을 클릭하게 되면 Playing! 다음에 You clicked! 가 노출된다.<br>만약 Upload Image버튼을 클릭하게 되면 Uploading! 다음에 You clicked! 가 노출된다.<br>※onScroll을 제외한 React 내의 모든 이벤트는 전파된다.<br>위의 예시에서 중요한 점은 onClick={() =&gt; { alert('You clicked!'); }} 이다.<br>만약 onClick={alert('You clicked!')} 을 하면 영역 또는 버튼을 클릭하기 전에 렌더링이 완료되자마자 alert이 뜨게 된다.<br>이는 즉시호출때문에 그런것이다.<br>그래서 영역 또는 버튼을 클릭했을때만 alert이 뜨게 하려면 onClick={() =&gt; { alert('You clicked!'); }} 을 써야 한다.<br><br><br>2. 이벤트 전파 멈추기<br>이벤트 핸들러는 이벤트 오브젝트를 유일한 매개변수로 받는다.<br>※관습적으로 이벤트 오브젝트는 e라는 명칭을 쓴다.<br>이 매개변수를 통해 이벤트 정보를 읽을 수 있으며, 이를 이용해 전파를 멈출 수 있게 할 수 있다.<br>e.stopPropagation()를 쓰면 된다.<br><br>function Button({ onClick, children }) {<br>  return (<br>    &lt;button onClick={e =&gt; {<br>      e.stopPropagation();<br>      onClick();<br>    }}&gt;<br>      {children}<br>    &lt;/button&gt;<br>  );<br>}<br><br>3. Capture<br>전파가 중단되었다 해도 자식 컴포넌트의 모든 이벤트를 캡처해 확인해야 할 경우에 쓰인다.<br>이벤트명 마지막에 Capture를 추가하면 된다고는 하는데,<br>어지간해서는 이걸 쓸 일은 없을 거라 생각된다.<br>해당 내용은 필요 시 찾아보도록 하자.<br><br>4. 이벤트 핸들러 전달 시 전파 멈추기<br>부모 영역인 div를 클릭했을 때의 이벤트는 방지하고 자식에게 전달되는 alert만 이벤트가 발생한다.<br>export default function MainComp() {<br>  const parentAlert = () =&gt; alert('부모 alert');<br>  return (<br>    &lt;div onClick={parentAlert}&gt;<br>      &lt;Button onClick={() =&gt; alert('전달한 alert')}&gt;<br>        버튼임<br>      &lt;/Button&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>function Button({onClick, children}) {<br>  return (<br>      &lt;button onClick={e =&gt; {<br>        e.stopPropagation();<br>        onClick();<br>      }}&gt;<br>      {children} <br>      &lt;/button&gt;<br>  );<br>}<br><br>5. 기본 동작 방지하기<br>일부 브라우저 이벤트는 그와 관련된 기본 브라우저 동작을 가진다.<br>예로 &lt;form&gt;의 이벤트는 그 내부의 버튼을 클릭 시 페이지 전체를 리로드하는 것이 기본 동작이다.<br>이를 방지하기 위해 아래와 같이 하면 된다.<br><br>export default function Signup() {<br>  return (<br>    &lt;form onSubmit={e =&gt; {<br>      e.preventDefault();<br>      alert('Submitting!');<br>    }}&gt;<br>      &lt;input /&gt;<br>      &lt;button&gt;Send&lt;/button&gt;<br>    &lt;/form&gt;<br>  );<br>}<br><br>※e.stopPropagation()와 e.preventDefault()는 서로 다른 기능이다 상세 기능은 아래와 같다.<br>e.stopPropagation()은 이벤트 핸들러가 상위 태그에서 실행되지 않도록 멈춘다.<br>e.preventDefault() 는 기본 브라우저 동작을 가진 일부 이벤트가 해당 기본 동작을 실행하지 않도록 방지한다.<br></mark>" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "상태(state)",
        "explain" : "<mark class='gray'>컴포넌트가 특정 정보를 기억하여 표시하고자 할 때 사용한다.<br>예를 들어 버튼이 클릭된 횟수를 세고 싶은 경우를 들 수 있다.<br><br>state를 사용하기 위해선 다음과 같이 하면 된다.<br>import { useState } from 'react';<br>const [명칭, set명칭] = useState(초기값);<br><br>const [명칭, set명칭]에서 첫번째 명칭 = 상태값(처음에는 초기값)이 세팅되는 변수. 이후 set명칭을 통해 업데이트 된 값이 들어가게 된다.<br>const [명칭, set명칭]에서 두번째 set명칭 = 상태를 업데이트 하는 함수. 안의 로직에 의해 변경된 값에 따라 상태를 변경하고 컴포넌트를 다시 렌더링하여 UI를 업데이트한다.<br><br>※명칭은 반드시 [명칭, set명칭]으로 할 필요는 없다. 예를 들어 [a, b] 이런식으로 해도 상관없다.<br>※하지만 일반적으로 [명칭, set명칭]으로 작성한다.<br>※useState의 초기값은 반드시 Number일 필요는 없다.<br>※초기값으로 문자열, 객체, 배열 등 어떤 데이터 타입도 사용할 수 있다. <br><br>※set명칭(3)과 명칭 = 3 의 차이<br>※set명칭(3)는 React의 상태 업데이트 함수로, 상태를 변경하고 컴포넌트를 다시 렌더링한다. 즉, 명칭의 값을 3으로 설정하고, 그에 따라 UI가 업데이트된다.<br>※반면에 명칭 = 3은 단순히 변수 명칭의 값을 변경하는 것이며, React의 상태 관리 시스템과는 관계가 없다. 즉 명칭=3은 React가 상태 변경을 인식하지 못하므로 UI가 업데이트되지 않는다. 따라서 setCount를 사용해야 한다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='xbxrmdg' data-pen-title='상태(state)' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/xbxrmdg'><br>상태(state)</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "Hook",
        "explain" : "<mark class='gray'>use로 시작하는 함수를 Hook이라고 한다.<br>예시에서 사용된 는 React에서 제공하는 내장 Hook이다.<br>Hook 종류는 여러가지가 있다.<br><br>Hook은 컴포넌트의 최상위 레벨에서만 호출해야 한다.<br>이는 React의 상태 관리와 렌더링 최적화를 위해 필요한 규칙이다.<br><br>또한 조건문이나 반복문 안에서 Hook을 호출하면 안된다.<br>React가 상태를 추적하는 데 어려움을 겪게 되어 예기치 않은 동작이 발생할 수 있기 떄문이다.</mark>" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='JojJxmw' data-pen-title='Hook' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/JojJxmw'><br>Hook</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "상품 테이블 실습",
        "explain" : "" ,
        "howUse" : "<p class='codepen' data-height='300' data-default-tab='html,result' data-slug-hash='dPyVyaY' data-pen-title='상품 테이블 실습' data-user='scrimer' style='height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;'><br><span>See the Pen <a href='https://codepen.io/scrimer/pen/dPyVyaY'><br>상품 테이블 실습</a> by lsj (<a href='https://codepen.io/scrimer'>@scrimer</a>)<br>on <a href='https://codepen.io'>CodePen</a>.</span><br></p><br><script async src='https://public.codepenassets.com/embed/index.js'></script>"       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    },
    {
        "type" : "",
        "reStudy" : "",
        "mainTitle" : "",
        "title" : "",
        "explain" : "" ,
        "howUse" : ""       
    }
]